[
  {
    "objectID": "02_model/02_thinning.html",
    "href": "02_model/02_thinning.html",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "",
    "text": "Thinning is a acceptance-rejection sampling method and is used to generate inter-arrival times from a NSPP.\n\nMotivation: In DES we use thinning as an approach to generate time dependent arrival of patients to a health care service.\n\n\n\nThe table below is adapted from Banks et al (2013) and breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between patient arrivals.\n\n\n\n\nA NSPP has arrival rate \\(\\lambda(t)\\) where \\(0 \\leq t \\leq T\\)\nHere \\(i\\) is the arrival number and \\(\\mathcal{T_i}\\) is its arrival time.\n\nLet \\(\\lambda^* = \\max_{0 \\leq t \\leq T}\\lambda(t)\\) be the maximum of the arrival rate function and set \\(t = 0\\) and \\(i=1\\)\nGenerate \\(e\\) from the exponential distribution with rate \\(\\lambda^*\\) and let \\(t = t + e\\) (this is the time of the next entity will arrive)\nGenerate \\(u\\) from the \\(U(0,1)\\) distribution. If \\(u \\leq \\dfrac{\\lambda(t)}{\\lambda^*}\\) then \\(\\mathcal{T_i} =t\\) and \\(i = i + 1\\)\nGo to Step 2."
  },
  {
    "objectID": "02_model/02_thinning.html#background",
    "href": "02_model/02_thinning.html#background",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "",
    "text": "Thinning is a acceptance-rejection sampling method and is used to generate inter-arrival times from a NSPP.\n\nMotivation: In DES we use thinning as an approach to generate time dependent arrival of patients to a health care service.\n\n\n\nThe table below is adapted from Banks et al (2013) and breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between patient arrivals.\n\n\n\n\nA NSPP has arrival rate \\(\\lambda(t)\\) where \\(0 \\leq t \\leq T\\)\nHere \\(i\\) is the arrival number and \\(\\mathcal{T_i}\\) is its arrival time.\n\nLet \\(\\lambda^* = \\max_{0 \\leq t \\leq T}\\lambda(t)\\) be the maximum of the arrival rate function and set \\(t = 0\\) and \\(i=1\\)\nGenerate \\(e\\) from the exponential distribution with rate \\(\\lambda^*\\) and let \\(t = t + e\\) (this is the time of the next entity will arrive)\nGenerate \\(u\\) from the \\(U(0,1)\\) distribution. If \\(u \\leq \\dfrac{\\lambda(t)}{\\lambda^*}\\) then \\(\\mathcal{T_i} =t\\) and \\(i = i + 1\\)\nGo to Step 2."
  },
  {
    "objectID": "02_model/02_thinning.html#imports",
    "href": "02_model/02_thinning.html#imports",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "2. Imports",
    "text": "2. Imports\n\nlibrary(simmer)\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))"
  },
  {
    "objectID": "02_model/02_thinning.html#read-in-data",
    "href": "02_model/02_thinning.html#read-in-data",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "3. Read in data",
    "text": "3. Read in data\nHere we read in the example non-stationary data and compute the arrival rate.\n\nNSPP_PATH = 'https://raw.githubusercontent.com/TomMonks/treat-sim-rsimmer/main/data/nspp_example1.csv'\n\ncsv_data &lt;- getURL(NSPP_PATH)\narrivals &lt;- read.csv(text=csv_data)\nnames(arrivals) &lt;- c(\"period\", \"mean_iat\")\n\n# create arrival rate\narrivals$arrival_rate = 1.0 / arrivals$mean_iat\n\narrivals\n\n  period mean_iat arrival_rate\n1      0       15   0.06666667\n2     60       12   0.08333333\n3    120        7   0.14285714\n4    180        5   0.20000000\n5    240        8   0.12500000\n6    300       10   0.10000000\n7    360       15   0.06666667\n8    420       20   0.05000000\n9    480       20   0.05000000\n\n\n\nggplot(data=arrivals, aes(x=period, y=mean_iat)) +\n  geom_bar(stat=\"identity\", fill=\"steelblue\") + \n  xlab(\"Time of day (mins)\") + \n  ylab(\"Mean IAT (min)\")"
  },
  {
    "objectID": "02_model/02_thinning.html#algorithm-implementation",
    "href": "02_model/02_thinning.html#algorithm-implementation",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "4. Algorithm implementation",
    "text": "4. Algorithm implementation\n\n4.1 NSPP sampling function\n\nnspp_thinning &lt;- function(simulation_time, data, debug=FALSE){\n  \n  # calc time interval: assumes intervals are of equal length\n  interval &lt;- data$period[2] - data$period[1]\n  \n  # maximum arrival rate (smallest time between arrivals)\n  lambda_max &lt;- max(data$arrival_rate)\n\n  while(TRUE){\n    # get time bucket (row of dataframe to use)\n    t &lt;- floor(simulation_time / interval) %% nrow(data) + 1\n    lambda_t &lt;- data$arrival_rate[t]\n    \n    # set to a large number so that at least 1 sample is taken\n    u &lt;- Inf\n    rejects &lt;- -1\n    \n    # running total of time until next arrival\n    inter_arrival_time &lt;- 0.0\n    \n    # reject proportionate to lambda_t / lambda_max\n    ratio &lt;- lambda_t / lambda_max\n    while(u &gt;= ratio){\n      rejects &lt;- rejects + 1\n      # sample using max arrival rate\n      inter_arrival_time &lt;- inter_arrival_time + rexp(1, lambda_max)\n      u &lt;- runif(1, 0.0, 1.0)\n    }\n    \n    if(debug){\n      print({paste(\"Time:\", simulation_time, \n                   \" Rejections:\", rejects, \n                   \" t:\", t, \n                   \" lambda_t:\", lambda_t, \n                   \" IAT:\", inter_arrival_time)})\n    }\n      \n    return(inter_arrival_time)\n  }\n}\n\n\n\n4.2 Example usage\nThe function can be used in the same way as rexp to generate new patients. To illustrate its use we first create a simple patient pathway trajectory that prints out some event and acts as a delay.\n\npatient &lt;- trajectory(\"patient pathway\") %&gt;% \n  # just a simple delay\n  log_(function() {paste(\"Patient arrival\")}, level = 1) %&gt;% \n  timeout(function() rnorm(1, 10.0, 1.0)) %&gt;% \n  log_(function() {paste(\"Exit treatment pathway\")}, level = 1)\n\nWe then run the model with a generator that uses the nspp_thinning sampling function. Note that the function accepts the current simulation time now(env) and the dataframe containing the arrivals arrivals.\n\nImportant learning point: we need to detach run from the creation of the simulation environment. This will allow now(env) to run correctly. If we ignore this rule and include run in the creation pipe the same time will be passed to the thinning function and it will under/over sample arrivals. See https://r-simmer.org/articles/simmer-03-trajectories.html\n\n\nenv &lt;- simmer(\"TreatSim\", log_level=0) \n\nenv %&gt;% \n  add_generator(\"patient\", patient, \n                function() nspp_thinning(now(env), arrivals, debug=TRUE)) %&gt;% \n  run(until=540.0)\n\n[1] \"Time: 0  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 3.76578976358814\"\n[1] \"Time: 3.76578976358814  Rejections: 2  t: 1  lambda_t: 0.0666666666666667  IAT: 8.77300580011165\"\n[1] \"Time: 12.5387955636998  Rejections: 3  t: 1  lambda_t: 0.0666666666666667  IAT: 4.28684175027315\"\n[1] \"Time: 16.8256373139729  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 4.29691788904072\"\n[1] \"Time: 21.1225552030137  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 0.977053523529321\"\n[1] \"Time: 22.099608726543  Rejections: 3  t: 1  lambda_t: 0.0666666666666667  IAT: 18.9426554942873\"\n[1] \"Time: 41.0422642208303  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 4.46571987774181\"\n[1] \"Time: 45.5079840985721  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 3.01859689779066\"\n[1] \"Time: 48.5265809963628  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 15.1711776387569\"\n[1] \"Time: 63.6977586351197  Rejections: 0  t: 2  lambda_t: 0.0833333333333333  IAT: 6.32943107259876\"\n[1] \"Time: 70.0271897077184  Rejections: 1  t: 2  lambda_t: 0.0833333333333333  IAT: 8.1247376101658\"\n[1] \"Time: 78.1519273178843  Rejections: 2  t: 2  lambda_t: 0.0833333333333333  IAT: 17.1277398191823\"\n[1] \"Time: 95.2796671370666  Rejections: 2  t: 2  lambda_t: 0.0833333333333333  IAT: 11.0189668625515\"\n[1] \"Time: 106.298633999618  Rejections: 4  t: 2  lambda_t: 0.0833333333333333  IAT: 29.4468570307807\"\n[1] \"Time: 135.745491030399  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 4.62095872012383\"\n[1] \"Time: 140.366449750523  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 3.51823921760029\"\n[1] \"Time: 143.884688968123  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 9.63292795191419\"\n[1] \"Time: 153.517616920037  Rejections: 1  t: 3  lambda_t: 0.142857142857143  IAT: 13.0159630631919\"\n[1] \"Time: 166.533579983229  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 1.34748264681548\"\n[1] \"Time: 167.881062630045  Rejections: 1  t: 3  lambda_t: 0.142857142857143  IAT: 17.6783432058039\"\n[1] \"Time: 185.559405835848  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 5.31185572014606\"\n[1] \"Time: 190.871261555995  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.962201000656933\"\n[1] \"Time: 191.833462556651  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 3.55364936848587\"\n[1] \"Time: 195.387111925137  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.16904162010178\"\n[1] \"Time: 195.556153545239  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.628217428456992\"\n[1] \"Time: 196.184370973696  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 3.19707098882645\"\n[1] \"Time: 199.381441962523  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 11.3105767969791\"\n[1] \"Time: 210.692018759502  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 11.2065692092508\"\n[1] \"Time: 221.898587968752  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 6.82710609377778\"\n[1] \"Time: 228.72569406253  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 6.70787511372423\"\n[1] \"Time: 235.433569176255  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 1.59553146317181\"\n[1] \"Time: 237.029100639426  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 11.4393470585904\"\n[1] \"Time: 248.468447698017  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 5.01644089468712\"\n[1] \"Time: 253.484888592704  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 0.649605868643447\"\n[1] \"Time: 254.134494461347  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 4.66810554131665\"\n[1] \"Time: 258.802600002664  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 2.31485183583573\"\n[1] \"Time: 261.1174518385  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 9.35887915971589\"\n[1] \"Time: 270.476330998216  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 2.05824714852497\"\n[1] \"Time: 272.534578146741  Rejections: 1  t: 5  lambda_t: 0.125  IAT: 4.02758108219132\"\n[1] \"Time: 276.562159228932  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 0.84484807215631\"\n[1] \"Time: 277.407007301088  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 2.94980774167925\"\n[1] \"Time: 280.356815042767  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 3.85646283139891\"\n[1] \"Time: 284.213277874166  Rejections: 3  t: 5  lambda_t: 0.125  IAT: 19.7837783098657\"\n[1] \"Time: 303.997056184032  Rejections: 3  t: 6  lambda_t: 0.1  IAT: 9.31223217376736\"\n[1] \"Time: 313.309288357799  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 0.805431655608118\"\n[1] \"Time: 314.114720013408  Rejections: 1  t: 6  lambda_t: 0.1  IAT: 3.66342705896501\"\n[1] \"Time: 317.778147072373  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 8.32235796413776\"\n[1] \"Time: 326.10050503651  Rejections: 1  t: 6  lambda_t: 0.1  IAT: 6.2989120785973\"\n[1] \"Time: 332.399417115108  Rejections: 1  t: 6  lambda_t: 0.1  IAT: 1.83348922990263\"\n[1] \"Time: 334.23290634501  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 2.6950060762465\"\n[1] \"Time: 336.927912421257  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 11.6237345630202\"\n[1] \"Time: 348.551646984277  Rejections: 3  t: 6  lambda_t: 0.1  IAT: 26.0107733944295\"\n[1] \"Time: 374.562420378706  Rejections: 11  t: 7  lambda_t: 0.0666666666666667  IAT: 77.000257809194\"\n[1] \"Time: 451.5626781879  Rejections: 0  t: 8  lambda_t: 0.05  IAT: 16.4108510383565\"\n[1] \"Time: 467.973529226257  Rejections: 4  t: 8  lambda_t: 0.05  IAT: 36.6029639213631\"\n[1] \"Time: 504.57649314762  Rejections: 2  t: 9  lambda_t: 0.05  IAT: 6.85376229442141\"\n[1] \"Time: 511.430255442041  Rejections: 0  t: 9  lambda_t: 0.05  IAT: 2.00198200764135\"\n[1] \"Time: 513.432237449683  Rejections: 1  t: 9  lambda_t: 0.05  IAT: 2.35749176004902\"\n[1] \"Time: 515.789729209732  Rejections: 0  t: 9  lambda_t: 0.05  IAT: 6.15918674019581\"\n[1] \"Time: 521.948915949927  Rejections: 2  t: 9  lambda_t: 0.05  IAT: 18.6613871532886\"\n\n\nsimmer environment: TreatSim | now: 540 | next: 540.610303103216\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 60 }"
  },
  {
    "objectID": "02_model/02_thinning.html#validation",
    "href": "02_model/02_thinning.html#validation",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "5. Validation",
    "text": "5. Validation\n\nThe total number of arrivals in 540 minutes\n\nHere we will repeat the same 10,000 times and then explore the distribution of the number of arrivals. If all has gone to plan this should be a Poisson distribution with mean ~53.\n\n# expected arrivals from data.\nround(sum(arrivals$arrival_rate * 60), 2)\n\n[1] 53.07\n\n\nWe can use the simmer function get_n_generated to return the number of patients generated.\n\narrivals_by_replication &lt;- function(envs){\n  results &lt;- vector()\n  for(env in envs){\n    results &lt;- c(results, get_n_generated(env, \"patient\"))\n  }\n  return(data.frame(results))\n}\n\n\nsingle_run &lt;- function(env, rep_number, run_length, debug_arrivals=FALSE){\n  env %&gt;% \n    add_generator(\"patient\", patient, \n                  function() nspp_thinning(now(env), arrivals, debug=debug_arrivals)) %&gt;% \n    run(until=540.0)\n  return(env)\n}\n\n\nRUN_LENGTH &lt;- 540.0\nN_REPS &lt;- 500\nSEED &lt;- 42\n\nset.seed(SEED)\n\npatient &lt;- trajectory(\"patient pathway\") %&gt;% \n  # just a simple delay\n  log_(function() {paste(\"Exit treatment pathway\")}, level = 1)\n\n# note unlike in simmer documentation we use a traditional for loop\n# instead of lapply. This allows us to separeate env creation\n# from run and preserve the environment interaction between NSPP \n# and current sim time.\nenvs = vector()\nfor(rep in 1:N_REPS){\n  env &lt;- simmer(\"TreatSim\", log_level=0) \n  single_run(env, i, RUN_LENGTH)\n  envs &lt;- c(envs, env)\n}\n\n# # get the number of arrivals generated\nresults &lt;- arrivals_by_replication(envs)\n\n# show mean number of arrivals. Should be close to 53\nmean(results$results)\n\n[1] 53.552\n\n\n\nggplot(results, aes(x=results)) + \n  geom_histogram(binwidth=1, fill=\"steelblue\") + \n  xlab(\"Patient arrivals in 540 minutes\") + \n  ylab(\"Replications\")"
  },
  {
    "objectID": "02_model/02_thinning.html#running-code",
    "href": "02_model/02_thinning.html#running-code",
    "title": "Simulating time-dependent arrivals using thinning",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Abstract",
    "section": "",
    "text": "The materials and methods in this documentation support work towards developing the S.T.A.R.S healthcare framework (Sharing Tools and Artifacts for Reproducible Simulations in healthcare). Long term S.T.A.R.S aims to support researchers share open simulation models regardless of language choice, improve the quality of sharing, and reduce the workload required to meet high standards of open science for the modelling and simulation community.\nThe code and written materials are a work in progress towards STARS version 2.0. It demonstrates the application od sharing a discrete-event simuilation model and associated research artifacts:\n\nAll artifacts in this repository are linked to study researchers via ORCIDs;\nModel code is made available under a GNU Public License version 3;\n[To do: validate and test R dependencies managed through renv]\nThe R code and simmer model are documented and explained in a quarto website served up by GitHub pages;\n[To do: the materials are deposited and made citatable using Zenodo;]\n[To do: The models are sharable with other researchers and the NHS without the need to install software.]"
  },
  {
    "objectID": "preface.html#towards-sharing-tools-artifacts-and-reproducible-simulation-a-simmer-model-examplar",
    "href": "preface.html#towards-sharing-tools-artifacts-and-reproducible-simulation-a-simmer-model-examplar",
    "title": "Abstract",
    "section": "",
    "text": "The materials and methods in this documentation support work towards developing the S.T.A.R.S healthcare framework (Sharing Tools and Artifacts for Reproducible Simulations in healthcare). Long term S.T.A.R.S aims to support researchers share open simulation models regardless of language choice, improve the quality of sharing, and reduce the workload required to meet high standards of open science for the modelling and simulation community.\nThe code and written materials are a work in progress towards STARS version 2.0. It demonstrates the application od sharing a discrete-event simuilation model and associated research artifacts:\n\nAll artifacts in this repository are linked to study researchers via ORCIDs;\nModel code is made available under a GNU Public License version 3;\n[To do: validate and test R dependencies managed through renv]\nThe R code and simmer model are documented and explained in a quarto website served up by GitHub pages;\n[To do: the materials are deposited and made citatable using Zenodo;]\n[To do: The models are sharable with other researchers and the NHS without the need to install software.]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "üí´ Towards Sharing Tools, Artifacts, and Reproducible Simulation: a simmer model example",
    "section": "",
    "text": "Reusehttps://creativecommons.org/licenses/by/4.0/CitationBibTeX citation:@online{monks,\n  author = {Monks, Thomas and Harper, Alison and Heather, Amy and\n    Mustafee, Navonil},\n  title = {üí´ {Towards} {Sharing} {Tools,} {Artifacts,} and\n    {Reproducible} {Simulation:} A `Simmer` Model Example},\n  url = {https://TomMonks.github.io/treat-sim-rsimmer//},\n  doi = {10.5555/12345678_fake},\n  langid = {en},\n  abstract = {The materials and methods in this documentation support\n    work towards developing the **S.T.A.R.S healthcare framework**\n    (**S**haring **T**ools and **A**rtifacts for **R**eproducible\n    **S**imulations in healthcare). Long term S.T.A.R.S aims to support\n    researchers share open simulation models regardless of language\n    choice, improve the quality of sharing, and reduce the workload\n    required to meet high standards of open science for the modelling\n    and simulation community. The code and written materials are a\n    **work in progress** towards STARS version 2.0. It demonstrates the\n    application od sharing a discrete-event simuilation model and\n    associated research artifacts: * All artifacts in this repository\n    are linked to study researchers via ORCIDs; * Model code is made\n    available under a GNU Public License version 3; * {[}**To do**:\n    validate and test R dependencies managed through `renv`{]} * The R\n    code and simmer model are documented and explained in a quarto\n    website served up by GitHub pages; * {[}**To do**: the materials are\n    deposited and made citatable using Zenodo;{]} * {[}**To do**: The\n    models are sharable with other researchers and the NHS without the\n    need to install software.{]}}\n}\nFor attribution, please cite this work as:\nMonks, Thomas, Alison Harper, Amy Heather, and Navonil Mustafee. n.d.\n‚Äúüí´ Towards Sharing Tools, Artifacts, and Reproducible Simulation:\nA `Simmer` Model Example.‚Äù Zenodo. https://doi.org/10.5555/12345678_fake."
  },
  {
    "objectID": "02_model/01_model.html",
    "href": "02_model/01_model.html",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "",
    "text": "Note: we are calculating KPIs using our own code here, but you can also use simmer.plot. Help with install of simmer.plot (igraph installation is the actual issue) on Linux based systems: https://r.igraph.org/articles/installation-troubleshooting#cannot-compile-igraph-from-sources-on-linux\n\nIf you make use of conda environments (via Anaconda/mini-conda/mini-forge/mamba), remember to conda deactivate before installation.\n\n\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nsuppressMessages(library(simmer.plot))\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))\nsuppressMessages(library(Rlab))\nsuppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))\n\noptions(dplyr.summarise.inform = FALSE)"
  },
  {
    "objectID": "02_model/01_model.html#imports",
    "href": "02_model/01_model.html#imports",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "",
    "text": "Note: we are calculating KPIs using our own code here, but you can also use simmer.plot. Help with install of simmer.plot (igraph installation is the actual issue) on Linux based systems: https://r.igraph.org/articles/installation-troubleshooting#cannot-compile-igraph-from-sources-on-linux\n\nIf you make use of conda environments (via Anaconda/mini-conda/mini-forge/mamba), remember to conda deactivate before installation.\n\n\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nsuppressMessages(library(simmer.plot))\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))\nsuppressMessages(library(Rlab))\nsuppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))\n\noptions(dplyr.summarise.inform = FALSE)"
  },
  {
    "objectID": "02_model/01_model.html#default-values-and-constants",
    "href": "02_model/01_model.html#default-values-and-constants",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "2. Default values and constants",
    "text": "2. Default values and constants\n\n2.1 Distribution parameters\n\n#' Mean and Variance of the underlying Normal Distribution\n#' \n#' @description\n#' `normal_moments_from_lognormal` calculates the mu and sigma\n#' of the normal distribution underlying a lognormal\n#' mean and standard \n#'\n#' @details\n#' `rlnorm` from `stats` is designed to sample from the lognormal distribution. \n#' The parameters is expects are moments of the underlying normal distribution\n#' Using sample mean and standard deviation this function calculates \n#' the mu and sigma of the normal distribution. source: https://blogs.sas.com/content/iml/2014/06/04/simulate-lognormal-data-with-specified-mean-and-variance.html\n#' \n#' @param mean A number. Sample mean.\n#' @param stdev A number. Sample standard deviation\n#' @returns A list \nnormal_moments_from_lognormal &lt;- function(mean, std){\n  phi &lt;- sqrt(std^2 + mean^2)\n  mu &lt;- log(mean**2/phi)\n  sigma &lt;- sqrt(log(phi^2/mean^2))\n  return(list(\"mu\" = mu, \"sigma\" = sigma))\n}\n\n\n# sign-in/triage parameters\nDEFAULT_TRIAGE_MEAN &lt;- 3.0\n\n# registration parameters (lognormal distribution)\nDEFAULT_REG_PARAMS &lt;- normal_moments_from_lognormal(5.0, sqrt(2.0))\n\n# examination parameters\nDEFAULT_EXAM_PARAMS = list(mean=16.0, var=3.0)\n\n# trauma/stabilisation\nDEFAULT_TRAUMA_MEAN &lt;- 90.0\n\n# Trauma treatment (lognormal distribution)\nDEFAULT_TRAUMA_TREATMENT_PARAMS &lt;- normal_moments_from_lognormal(30.0, sqrt(4.0))\n\n# Non trauma treatment (lognormal distribution)\nDEFAULT_NON_TRAUMA_TREATMENT_PARAMS &lt;- normal_moments_from_lognormal(13.3, sqrt(2.0))\n\n# prob patient requires treatment given trauma\nDEFAULT_NON_TRAUMA_TREAT_P &lt;- 0.60\n\n# proportion of patients triaged as trauma\nDEFAULT_PROB_TRAUMA &lt;- 0.12\n\n\n\n2.2 Time dependent arrival rate data\nThe data for arrival rates varies between clinic opening at 6am and closure at 12am.\n\n# data are held in the Github repo and loaded from there.\nNSPP_PATH = 'https://raw.githubusercontent.com/TomMonks/open-science-for-sim/main/src/notebooks/01_foss_sim/data/ed_arrivals.csv'\n\ncsv_data &lt;- getURL(NSPP_PATH)\ndf &lt;- read.csv(text=csv_data)\n\n# lock in order of time of day for bar chart display\ndf$period &lt;- factor(df$period, levels = df$period)\n\nggplot(data=df, aes(x=period, y=arrival_rate)) +\n  geom_bar(stat=\"identity\", fill=\"steelblue\") + \n  theme(axis.text.x = element_text(angle = 90, \n                                   vjust = 0.5, \n                                   hjust=1)) +\n  xlab(\"Hour of day\") + \n  ylab(\"Mean arrivals (patients/hr)\")\n\n\n\n\n\n\n2.3 Resource Counts\nInteger count variables representing the number of resources at each activity in the process\n\nDEFAULT_N_TRIAGE &lt;- 1\nDEFAULT_N_REG &lt;- 1\nDEFAULT_N_EXAM &lt;- 3\n\n# stabilisation rooms\nDEFAULT_N_TRAUMA &lt;- 10000\n\n# Non-trauma cubicles\nDEFAULT_NON_TRAUMA_CUBICLES &lt;- 1\n\n# trauma pathway cubicles\nDEFAULT_TRAUMA_CUBICLES &lt;- 1\n\n\n\n2.4 Simulation model run settings\n\n# Random seed - this will be investigated for CRN\nSEED &lt;- 42\n\n# default results collection period\nDEFAULT_RESULTS_COLLECTION_PERIOD &lt;- 60 * 19\n\n# number of replications.\nDEFAULT_N_REPS &lt;- 5\n\n# Show the a trace of simulated events\n# 1 = show, 0 = do not show.\nLOG_LEVEL &lt;- 1"
  },
  {
    "objectID": "02_model/01_model.html#functions",
    "href": "02_model/01_model.html#functions",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "3. Functions",
    "text": "3. Functions\nLoad and format data\n\nload_arrival_data &lt;- function(path=NSPP_PATH){\n  csv_data &lt;- getURL(NSPP_PATH)\n  df &lt;- read.csv(text=csv_data)\n  \n  # arrivals per minute...\n  df$arrival_rate2 &lt;- df$arrival_rate/60.0\n  \n  # create 60 minute increments for period\n  df$period = seq(0, (nrow(df)-1)*60, by=60)\n  return(df)\n}\n\n\n#' Sample a patient type\n#' \n#' @description\n#' `sample_arrival_type` samples if a patient type is trauma or non-trauma\n#' with a given probability.\n#'\n#' @details\n#' The function uses the Bernouli distribution (Rlab) to sample\n#' if a patient is Trauma or Non-Trauma.  The return values are \n#' 1 = Trauma, 2 = Non-trauma.\n#' @param p A number: the probability a patient has trauma on arrival\nsample_arrival_type &lt;- function(p, n=1){\n  ifelse(rbern(n, prob = DEFAULT_PROB_TRAUMA) == 1, 1, 2)\n}\n\n\n#' Sample a if a non-trauma patient requires treatment\n#' \n#' @description\n#' `sample_nt_trauma_treatment` samples if a non-trauma patient\n#' requires cubicle treatment\n#'\n#' @details\n#' The function uses the Bernouli distribution (Rlab) to sample\n#' if a patient is requires treatment or not.  The return values are \n#' 1 = Treatment, 0 = No treatment\n#' @param p A number: The probability the patient requires treatment\nsample_nt_trauma_treatment &lt;- function(p){\n  ifelse(rbern(1, prob = p) == 1, 1, 0)\n}\n\nSampling from a non-stationary poisson process using thinning\n\nnspp_thinning &lt;- function(simulation_time, data, debug=FALSE){\n  \n  # calc time interval: assumes intervals are of equal length\n  interval &lt;- data$period[2] - data$period[1]\n  \n  # maximum arrival rate (smallest time between arrivals)\n  lambda_max &lt;- max(data$arrival_rate2)\n\n  while(TRUE){\n    # get time bucket (row of dataframe to use)\n    t &lt;- floor(simulation_time / interval) %% nrow(data) + 1\n    lambda_t &lt;- data$arrival_rate2[t]\n    \n    # set to a large number so that at least 1 sample is taken\n    u &lt;- Inf\n    rejects &lt;- -1\n    \n    # running total of time until next arrival\n    inter_arrival_time &lt;- 0.0\n    \n    # reject proportionate to lambda_t / lambda_max\n    ratio &lt;- lambda_t / lambda_max\n    while(u &gt;= ratio){\n      rejects &lt;- rejects + 1\n      # sample using max arrival rate\n      inter_arrival_time &lt;- inter_arrival_time + rexp(1, lambda_max)\n      u &lt;- runif(1, 0.0, 1.0)\n    }\n    \n    if(debug){\n      print({paste(\"Time:\", simulation_time, \n                   \" Rejections:\", rejects, \n                   \" t:\", t, \n                   \" lambda_t:\", lambda_t, \n                   \" IAT:\", inter_arrival_time)})\n    }\n      \n    return(inter_arrival_time)\n  }\n}"
  },
  {
    "objectID": "02_model/01_model.html#model-parameterisation",
    "href": "02_model/01_model.html#model-parameterisation",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "4. Model parameterisation",
    "text": "4. Model parameterisation\nThe model is setup to be created from a set of functions that return trajectories. Each function accepts a list that contains all parameters to configure the simulation model. Here we create the list and pre-populate it using default values.\n\ncreate_experiment &lt;- function(n_triage_bays=DEFAULT_N_TRIAGE,\n                              n_reg_clerks=DEFAULT_N_REG,\n                              n_exam_rooms=DEFAULT_N_EXAM,\n                              n_trauma_rooms=DEFAULT_N_TRAUMA,\n                              n_non_trauma_cubicles=DEFAULT_NON_TRAUMA_CUBICLES,\n                              n_trauma_cubicles=DEFAULT_TRAUMA_CUBICLES,\n                              triage_mean=DEFAULT_TRIAGE_MEAN,\n                              stabilisation_mean=DEFAULT_TRAUMA_MEAN,\n                              trauma_treat_params=DEFAULT_TRAUMA_TREATMENT_PARAMS,\n                              reg_params=DEFAULT_REG_PARAMS,\n                              exam_params=DEFAULT_EXAM_PARAMS,\n                              prob_non_trauma_treat=DEFAULT_NON_TRAUMA_TREAT_P,\n                              nontrauma_treat_params=DEFAULT_NON_TRAUMA_TREATMENT_PARAMS,\n                              prob_trauma=DEFAULT_PROB_TRAUMA,\n                              arrival_data_path=NSPP_PATH,\n                              log_level=LOG_LEVEL) {\n  \n  # load arrival data\n  arrival_data &lt;- load_arrival_data(path=arrival_data_path)\n  \n  # create list of parameters\n  experiment &lt;- list(n_triage_bays=n_triage_bays,\n                    n_reg_clerks=n_reg_clerks,\n                    n_exam_rooms=n_exam_rooms,\n                    n_trauma_rooms=n_trauma_rooms,\n                    n_non_trauma_cubicles=n_non_trauma_cubicles,\n                    n_trauma_cubicles=n_trauma_cubicles,\n                    triage_mean=triage_mean,\n                    stabilisation_mean=stabilisation_mean,\n                    trauma_treat_params=trauma_treat_params,\n                    reg_params=reg_params,\n                    exam_params=exam_params,\n                    prob_non_trauma_treat=prob_non_trauma_treat,\n                    nontrauma_treat_params=nontrauma_treat_params,\n                    prob_trauma=prob_trauma,\n                    arrival_data=arrival_data,\n                    log_level=log_level)\n  \n  return(experiment)\n}"
  },
  {
    "objectID": "02_model/01_model.html#patient-trajectories",
    "href": "02_model/01_model.html#patient-trajectories",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "5. Patient Trajectories",
    "text": "5. Patient Trajectories\nThe DES package simmer uses the concept of a trajectory to model a process for a particular patient type. In the urgent care centre example trajectories allow us to model separate trauma and non-trauma processes. Note that different trajectories can share common resources.\nThe simmer terminology for using resources and engaging in activities is easy to read:\n\nseize - queue and take a resource when it is available.\ntimeout - a process delay (e.g.¬†treatment or diagnostics)\nrelease - release a resource.\n\nsimmer also provides a way to set an attribute of the trajectory using set_attribute. This is useful for storing timing information to display in a log: for example when a patient begins waiting for a resource (access via now(env)).\n\nImportant notes:\n\nThe function log_ is used in combination with function() paste to provide a dynamic simulation trace to the R console.\nSampling code should look as follows:\n\ntimeout(task = function() rexp(1, 3.0)) %&gt;%\n\nThe keyword function() must be included for dynamic sampling for each patient. Omitting function() means that it is evaluated once at the time the trajectory is created.\n\n\n\n5.1. Trauma Patients\n\nWe wrap the trajectory in a function called create_trauma_pathway. This allows us to pass an argument exp that can parameterise the trajectory for use in a discrete experiment.\n\n\ncreate_trauma_pathway &lt;- function(exp){\n    \n    trauma_pathway &lt;- trajectory(name=\"trauma_pathway\") %&gt;%\n      set_attribute(\"patient_type\", 1) %&gt;%\n      # log patient arrival\n      log_(function() {paste(\"**Trauma arrival\")}, level=1) %&gt;% \n      \n      # triage \n      set_attribute(\"start_triage_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"triage_bay\", function() rexp(1, 1/exp$triage_mean)) %&gt;%\n      log_(function() {paste(\"(T) Triage wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n           level=1) %&gt;%\n      \n      # request trauma room for stabilization\n      set_attribute(\"start_trauma_room_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"trauma_room\", function() rexp(1, 1/exp$stabilisation_mean)) %&gt;%\n      log_(function() {paste(\"(T) Trauma room wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_trauma_room_wait\"))},\n           level=1) %&gt;%\n      \n      # request treatment cubicle\n      set_attribute(\"start_trauma_treat_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"trauma_treat_cubicle\", function() rlnorm(1, exp$trauma_treat_params$mu,\n                                                      exp$trauma_treat_params$sigma)) %&gt;%\n      log_(function() {paste(\"********************(T) Trauma treatment cubicle wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_trauma_treat_wait\"))},\n           level=1) %&gt;% \n    \n      # store the total time in system \n      set_attribute(\"total_time\", \n                    function() {now(exp$env) - get_attribute(exp$env, \"start_triage_wait\")})\n    \n  return(trauma_pathway)\n}\n\n\n\n5.2 Non-trauma patients\n\ncreate_nt_cubicle_treatment &lt;- function(exp){\n\n  nt_cubicle_treatment &lt;- trajectory() %&gt;% \n    log_(function() {paste(\"NT patient requirement treatment\")},\n         level=1) %&gt;% \n    seize(resource=\"nontrauma_treat_cubicle\", amount=1) %&gt;% \n    \n    timeout(task = function() rlnorm(1, exp$nontrauma_treat_params$mu,                                                     exp$nontrauma_treat_params$sigma)) %&gt;%\n    release(resource = \"nontrauma_treat_cubicle\", amount = 1) %&gt;% \n    log_(function() {paste(\"NT treatment complete\")},\n     level=1) %&gt;% \n  return(nt_cubicle_treatment)\n}\n\n\ncreate_non_trauma_pathway &lt;- function(exp){\n  # log messages\n  ARRIVAL_MSG = \"**Non-Trauma arrival**\"\n  TRIAGE_MSG = \"(NT) Triage wait time:\"\n  REG_MSG = \"Reg wait time:\"\n  EXAM_MSG = \"Exam wait time:\"\n  EXIT_MSG = \"NT Total time in system:\"\n  \n  # optional trajectory for proportion of patients that requirement treatment\n  nt_cubicle_treatment &lt;- create_nt_cubicle_treatment(exp)\n  \n  non_trauma_pathway &lt;- trajectory(name=\"non_trauma_pathway\") %&gt;%\n    set_attribute(\"patient_type\", 2) %&gt;%\n    # log non_trauma arrival\n    log_(function() {paste(ARRIVAL_MSG)}, level=1) %&gt;% \n    \n    # store start of waiting time for log calculations\n    set_attribute(\"start_triage_wait\", function() {now(exp$env)}) %&gt;%\n    # queue and use triage bay\n    visit(\"triage_bay\", function() rexp(1, 1/exp$triage_mean)) %&gt;%\n    log_(function() {paste(TRIAGE_MSG, now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %&gt;%\n    \n    # queue and use registration clerk\n    set_attribute(\"start_reg_wait\", function() {now(exp$env)}) %&gt;%\n    visit(\"registration_clerk\", function() rlnorm(1, exp$reg_params$mu, \n                                                  exp$reg_params$sigma)) %&gt;%\n    log_(function() {paste(REG_MSG, now(exp$env) - get_attribute(exp$env, \"start_reg_wait\"))},\n         level=1) %&gt;%\n    \n    # queue and use examination room\n    set_attribute(\"start_exam_wait\", function() {now(exp$env)}) %&gt;%\n    visit(\"examination_room\",  function() rnorm(1, exp$exam_params$mean, \n                                                sqrt(exp$exam_params$var))) %&gt;%\n    log_(function() {paste(EXAM_MSG, now(exp$env) - get_attribute(exp$env, \"start_exam_wait\"))},\n         level=1) %&gt;%\n    \n    # a Proportion of patients require treatment in a cubicle\n    branch (\n      function() sample_nt_trauma_treatment(exp$prob_non_trauma_treat), continue=T,\n      nt_cubicle_treatment\n    ) %&gt;% \n    log_(function() {paste(EXIT_MSG, now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %&gt;% \n    # store the total time in system \n    set_attribute(\"total_time\", \n                    function() {now(exp$env) - get_attribute(exp$env, \"start_triage_wait\")})\n  \n  return(non_trauma_pathway)\n}"
  },
  {
    "objectID": "02_model/01_model.html#modelling-patient-arrivals",
    "href": "02_model/01_model.html#modelling-patient-arrivals",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "6. Modelling patient arrivals",
    "text": "6. Modelling patient arrivals\nPatients arrive a the urgent treatment centre following a time dependent process. When patients arrive they are classified as trauma or non-trauma.\nTo modify the classification of patients we will use a trajectory that uses the `branch` function from simmer.\nThe function `sample_arrival_type` returns a 1 (trauma) or 2 (non-trauma). This is used to select the appropriate patient trajectory.\n\ncreate_arrival_generator &lt;- function(exp){\n  \n  DEPART_MSG &lt;- \"A patient has departed the UTC\"\n  \n  # create and parameterise the trauma pathway trajectory\n  trauma_pathway &lt;- create_trauma_pathway(exp)\n  \n  # create and parameterise the non-trauma pathway trajectory\n  non_trauma_pathway &lt;- create_non_trauma_pathway(exp)\n  \n  patient_arrival &lt;- trajectory() %&gt;%\n    branch(\n      function() sample_arrival_type(exp$prob_trauma), continue=T,\n        trauma_pathway,\n        non_trauma_pathway\n    ) %&gt;%\n    log_(function() {paste(DEPART_MSG)},level=1) %&gt;% \n    set_attribute(\"departed\", 1)\n  \n  return(patient_arrival)\n}"
  },
  {
    "objectID": "02_model/01_model.html#single-run-of-the-model",
    "href": "02_model/01_model.html#single-run-of-the-model",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "7. Single run of the model",
    "text": "7. Single run of the model\n\nWork in progress\n\n\nsingle_run &lt;- function(env, exp, \n                       rep_number=1, \n                       run_length=DEFAULT_RESULTS_COLLECTION_PERIOD, \n                       debug_arrivals=FALSE){\n  # add the simmer environment to the experiment list.\n  exp &lt;- c(exp, env=env) \n  \n  # Create the arrivals generator\n  arrival_gen &lt;- create_arrival_generator(exp)\n  \n  # create model and run.\n  env %&gt;% \n    add_resource(\"triage_bay\", exp$n_triage_bays) %&gt;%\n    add_resource(\"registration_clerk\", exp$n_reg_clerks) %&gt;%\n    add_resource(\"examination_room\", exp$n_exam_rooms) %&gt;%\n    add_resource(\"trauma_room\", exp$n_trauma_rooms) %&gt;%\n    add_resource(\"trauma_treat_cubicle\", exp$n_trauma_cubicles) %&gt;%\n    add_resource(\"nontrauma_treat_cubicle\", exp$n_non_trauma_cubicles) %&gt;%\n    add_generator(\"Patient\", arrival_gen, \n                  function() nspp_thinning(now(env), exp$arrival_data, \n                                           debug=debug_arrivals),\n                  mon=2) %&gt;% \n    run(until=run_length)\n  \n  # return environment and all of its results.\n  return(env)\n}\n\nScript to conduct single run of the model\n\nNote that the environment is created outside of the single_run function. This is to separate the creation of the environment from the run function call. The reason is so that the now(env) function will work correctly in the nspp_thinning sampling function (if we do not separate then the same time is always passed to the function).\n\n\nset.seed(SEED)\nexp &lt;- create_experiment(log_level=0)\ntreat_sim &lt;- simmer(\"TreatSim\", log_level=exp$log_level)\ntreat_sim &lt;- single_run(treat_sim, exp)\nprint(\"Simulation Complete.\")\n\n[1] \"Simulation Complete.\""
  },
  {
    "objectID": "02_model/01_model.html#multiple-replications",
    "href": "02_model/01_model.html#multiple-replications",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "8. Multiple replications",
    "text": "8. Multiple replications\n\nN_REPS &lt;- 50\n\nset.seed(42)\n\n# note unlike in simmer documentation we use a traditional for loop\n# instead of lapply. This allows us to separate env creation\n# from run and preserve the environment interaction between NSPP \n# and current sim time.\n# TO DO: look again -&gt; can treat_sim be created inside single_run()\nprint(\"running replications...\")\n\n[1] \"running replications...\"\n\nreps = vector()\nfor(rep in 1:N_REPS){\n  exp &lt;- create_experiment(log_level=0)\n  treat_sim &lt;- simmer(\"TreatSim\", log_level=exp$log_level)\n  treat_sim &lt;- single_run(treat_sim, exp)\n  # store the latest simulation enviornment and its results.\n  reps &lt;- c(reps, treat_sim)\n}\nprint(\"Complete.\")\n\n[1] \"Complete.\""
  },
  {
    "objectID": "02_model/01_model.html#results-analysis",
    "href": "02_model/01_model.html#results-analysis",
    "title": "Treatment Sim: an R simmer implementation",
    "section": "9. Results analysis",
    "text": "9. Results analysis\nAnalysis of simmer results is achieved using a mix of statistics collected automatically and custom attributes set by the modeller during the run.\nIn general, we follow a typical strategy in a simulation study. We calculate the mean Key Performance Indicator (KPI) seen during an individual replication of the model (e.g.¬†waiting time for triage and utilisation of the the triage rooms). This is repeated for all replications and the distribution of results can be visualised or we use a summary measure such as the mean.\nBelow we construct a summary table of results providing the mean of 16 KPIs.\n\nCode quality is a work in progress. üòÉ\n\n\narrivals_by_replication &lt;- function(envs){\n  results &lt;- vector()\n  for(env in envs){\n    results &lt;- c(results, get_n_generated(env, \"Patient\"))\n  }\n  return(data.frame(results))\n}\n\n\nget_resource_counts &lt;- function(exp) {\n  resource = c(\"triage_bay\", \n                \"registration_clerk\", \n                \"examination_room\",\n                \"trauma_room\",\n                \"trauma_treat_cubicle\",\n                \"nontrauma_treat_cubicle\")\n  \n  resource_counts = c(exp$n_triage_bays,\n                      exp$n_reg_clerks,\n                      exp$n_exam_rooms,\n                      exp$n_trauma_rooms,\n                      exp$n_trauma_cubicles,\n                      exp$n_non_trauma_cubicles)\n  \n  df_resource &lt;- data.frame(resource)\n  df_resource$count &lt;- resource_counts\n  return(df_resource)\n}\n\nFunctions to calculate KPIs from custom attributes\n\n# mean time in the system and throughput\ncalc_kpi_from_attributes_for_rep &lt;- function(rep){\n  \n  # get attributes\n  att &lt;- get_mon_attributes(reps)\n  # for speed - limit to replication number.\n  rep_att &lt;- subset(att[att$replication == rep,], select = c(name, key, value))\n  # long to wide format...\n  data_wide &lt;- spread(rep_att, key, value)\n  \n  # Patient type 1: trauma\n  # take the mean and ignore patients still in pathway\n  mean_time_1 = mean(data_wide[data_wide$patient_type == 1,]$total_time, na.rm = TRUE)\n  \n  # Patient type 2: non_trauma\n  # take the mean and ignore patients still in pathway\n  mean_time_2 = mean(data_wide[data_wide$patient_type == 2,]$total_time, na.rm = TRUE)\n  \n  # Throughput - discharges during opening hours.\n  throughput &lt;- sum(data_wide$departed, na.rm=TRUE)\n  \n  # store and return data.frame of results\n  rep_results &lt;- data.frame(\"05_total_time(non-trauma)\" = mean_time_2,\n                            \"08_total_time(trauma)\" = mean_time_1, \n                            \"09_throughput\"= throughput)\n  return(rep_results)\n}\n\ncalc_kpi_from_attributes &lt;- function(){\n  # calcs total time by patient type and total throughput\n  \n  # empty dataframe for attribute calculations.\n  att_results &lt;- data.frame(matrix(ncol = 3, nrow = 0))\n  colnames(att_results) &lt;- c(\"05_total_time(non-trauma)\", \"08_total_time(trauma)\", \"09_throughput\")\n\n  # add each rep separately as this works faster with pivot\n  for(rep in 1:N_REPS){\n    att_results &lt;- rbind(att_results, calc_kpi_from_attributes_for_rep(rep))\n  }\n\n  # return the KPIs by replications\n  return(att_results)\n}\n\n\ncreate_summary_table &lt;- function(reps, exp, dp=2){\n\n  # mean number of arrivals\n  arrival_counts &lt;- arrivals_by_replication(reps)\n  mean_arrivals &lt;- mean(arrival_counts$results)\n  arrival_df &lt;- data.frame(\"00_arrivals\", mean_arrivals)\n  names(arrival_df)&lt;-c(\"kpi\",\"mean\")\n\n  \n  # get results dataframe broken down by resource and replication.\n  arrivals &lt;- get_mon_arrivals(reps, per_resource=TRUE)\n  \n  # calculate waiting time\n  arrivals$waiting_time &lt;-arrivals$end_time - arrivals$start_time - arrivals$activity_time\n  # arrivals$waiting_time &lt;- round(arrivals$waiting_time, 2)\n  \n  cols &lt;- c(\"resource\", \"replication\")\n  summary_wait &lt;- arrivals %&gt;%\n    # mean waiting time in each replication\n    group_by(across(all_of(cols))) %&gt;%\n    summarise(rep_waiting_time=mean(waiting_time)) %&gt;% \n    # mean waiting time across replications\n    group_by(resource) %&gt;% \n    summarise(mean=mean(rep_waiting_time)) %&gt;% \n    mutate(resource=recode(resource,  \n                         'triage_bay'='01a_triage_wait', \n                         'registration_clerk'='02a_registration_wait',\n                         'examination_room'='03a_examination_wait',\n                         'nontrauma_treat_cubicle'='04a_treatment_wait(non_trauma)',\n                         'trauma_room'='06a_stabilisation_wait',\n                         'trauma_treat_cubicle'='07a_treatment_wait(trauma)')) %&gt;% \n    arrange(resource)\n  \n  \n  names(summary_wait)&lt;-c(\"kpi\",\"mean\")\n  \n  # utilisation calculation:\n  # simple calculation of total busy time / total scheduled resource time.\n  # where total scheduled time = n_resource * results collection period.\n  summary_util &lt;- arrivals %&gt;%\n    # mean waiting time in each replication\n    group_by(across(all_of(cols))) %&gt;%\n    summarise(in_use=sum(activity_time)) %&gt;% \n    arrange(resource)\n  \n  # add resource counts to table for calc\n  summary_util &lt;- merge(summary_util, get_resource_counts(exp), \n                        by=\"resource\", all=TRUE)\n  \n  # total in use / total scheduled time\n  summary_util$util = summary_util$in_use / (DEFAULT_RESULTS_COLLECTION_PERIOD * summary_util$count)  \n  \n  summary_util &lt;- summary_util %&gt;%\n    # mean waiting time in each replication\n    group_by(resource) %&gt;%\n    summarise(mean=mean(util)) %&gt;% \n    mutate(resource=recode(resource,  \n                         'triage_bay'='01b_triage_util', \n                         'registration_clerk'='02b_registration_util',\n                         'examination_room'='03b_examination_util',\n                         'nontrauma_treat_cubicle'='04b_treatment_util(non_trauma)',\n                         'trauma_room'='06b_stabilisation_util',\n                         'trauma_treat_cubicle'='07b_treatment_util(trauma)')) %&gt;% \n    arrange(resource)\n\n  names(summary_util) &lt;- c(\"kpi\",\"mean\")\n  \n  overall &lt;- bind_rows(arrival_df, summary_wait, summary_util) %&gt;% \n    arrange(kpi) \n  \n  ## KPIs calculated from attributes\n  # empty dataframe for attribute calculations.\n  att_results &lt;- calc_kpi_from_attributes()\n  mean_att_results &lt;- colMeans(att_results)\n\n  overall &lt;- overall %&gt;%\n    add_row(kpi=\"05_total_time(non-trauma)\", mean=mean_att_results[1]) %&gt;%\n    add_row(kpi=\"08_total_time(trauma)\", mean=mean_att_results[2]) %&gt;%\n    add_row(kpi=\"09_throughput\", mean=mean_att_results[3]) %&gt;%\n    arrange(kpi)\n  \n  # round and return\n  overall$mean &lt;- round(overall$mean, dp)\n  return(overall)\n}\n\n\nresults_summary &lt;- create_summary_table(reps, exp)\nresults_summary\n\n                              kpi   mean\n1                     00_arrivals 230.48\n2                 01a_triage_wait  34.05\n3                 01b_triage_util   0.60\n4           02a_registration_wait 107.45\n5           02b_registration_util   0.84\n6            03a_examination_wait  23.92\n7            03b_examination_util   0.84\n8  04a_treatment_wait(non_trauma) 139.57\n9  04b_treatment_util(non_trauma)   0.87\n10      05_total_time(non-trauma) 236.96\n11         06a_stabilisation_wait   0.00\n12         06b_stabilisation_util   0.00\n13     07a_treatment_wait(trauma)  53.18\n14     07b_treatment_util(trauma)   0.65\n15          08_total_time(trauma) 197.52\n16                  09_throughput 168.54"
  }
]