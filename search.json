[
  {
    "objectID": "02_model/03_r_sampling.html",
    "href": "02_model/03_r_sampling.html",
    "title": "Sampling in R",
    "section": "",
    "text": "By default R offers less control over random sampling than python and commercial simulation software. It uses a single random number stream for all sampling and does not allow you to create individual random number streams (each with its own seed) for each sampling distribution.\n\nThis is not ideal for DES, and has a range of impacts. The one you will likely experience is additional noise between experiments due to this lack of control.\nThe result is typically that you need to run a lot more replications to carefully assess difference between experiments. It is also harder to debug experiments.\n\nTo illustrate the impact of this design consider the example below. Imagine we are going to simulate 5 patients length of stay (LoS) in an acute hospital followed by rehabilitation. Acute LoS is exponentially distribution while rehabilitation LoS follows a uniform distribution (the choice of distribution does not matter).\n\nIMPORTANT: To make the results ‚Äúrepeatable‚Äù as possible we will set a random seed. With a single random stream we will see that this does not guarantee repeatable samples for patients between experiments.\n\n\n\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nlibrary(magrittr)\n\n\n\n\n\nSEED &lt;- 42\nACUTE_MEAN &lt;- 32.0\nREHAB_MIN &lt;- 15.0\nREHAB_MAX &lt;- 80.0\n\n\n\n\n\nn_patients &lt;- 5\n\nset.seed(SEED)\nacute_los &lt;- rexp(n=n_patients, rate=1.0/ACUTE_MEAN)\nrehab_los &lt;- runif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX)\n\nprint(acute_los)\n\n[1]  6.346778 21.148648  9.071713  1.222141 15.141652\n\nprint(rehab_los)\n\n[1] 23.75333 57.70450 60.82921 44.75322 61.74230\n\n\n\n\n\nWe will now reset the random stream using the same seed and limit the number of patients simulated to 2.\nWhen we re-run the code we might expect to get\n\nAcute Los:\n6.346778 21.148648\nRehab Los:\n23.75333 57.70450\n\nBut we will see that this does not happen. This is because all sampling makes use of a pseudo random number stream that generates uniformly distribution numbers \\(U\\)‚Äôs between 0 and 1. When only 1 stream is used for all sampling we can end up with lots of noise between experiments simply because different \\(U\\)‚Äôs are used for the same patients.\n\nn_patients &lt;- 2\n\nset.seed(SEED)\nacute_los &lt;- rexp(n=n_patients, rate=1.0/ACUTE_MEAN)\nrehab_los &lt;- runif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX)\n\nprint(acute_los)\n\n[1]  6.346778 21.148648\n\nprint(rehab_los)\n\n[1] 56.71346 48.74124\n\n\n\n\n\nTo force the order of sampling within a single random number stream each patient must do their sampling upfront and in process order.\nBelow we re-run Experiments 1 and 2, but this time we make sure the process is sampled in order (acute then rehab) for each patient.\n\n\n\nn_patients &lt;- 3\n\nset.seed(SEED)\n\nfor (patient_i in 1:n_patients) {\n    print(paste(\"Patient \", patient_i))\n    print(paste(\"Acute \", rexp(n=1, rate=1.0/ACUTE_MEAN)))\n    print(paste(\"Rehab \", runif(n=1, min=REHAB_MIN, max=REHAB_MAX)))\n}\n\n[1] \"Patient  1\"\n[1] \"Acute  6.34677797708443\"\n[1] \"Rehab  68.9790956943762\"\n[1] \"Patient  2\"\n[1] \"Acute  9.07171320915222\"\n[1] \"Rehab  48.7412366934586\"\n[1] \"Patient  3\"\n[1] \"Acute  15.1416521370411\"\n[1] \"Rehab  23.7533288204577\"\n\n\n\n\n\n\nn_patients &lt;- 2\n\nset.seed(SEED)\n\nfor (patient_i in 1:n_patients) {\n    print(paste(\"Patient \", patient_i))\n    print(paste(\"Acute \", rexp(n=1, rate=1.0/ACUTE_MEAN)))\n    print(paste(\"Rehab \", runif(n=1, min=REHAB_MIN, max=REHAB_MAX)))\n}\n\n[1] \"Patient  1\"\n[1] \"Acute  6.34677797708443\"\n[1] \"Rehab  68.9790956943762\"\n[1] \"Patient  2\"\n[1] \"Acute  9.07171320915222\"\n[1] \"Rehab  48.7412366934586\"\n\n\n\n\n\n\nBy default simmer will be affected by the single random stream for all sampling. This is because in a DES sampling will not occur in process order like we saw above. The numbers generated will vary depending on when events are scheduled to take place.\nWe will first consider this in experiments where we control the exact number of arrivals. In these experiments we will not use resources. This means that there is no impact on the model due to queuing if we increase or decrease the number of arrivals to the model.\n\nTo simplify output we display the time patients exit acute and rehab activities.\n\n\n\n\n# set the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_1\") \n\n# setup simple patient trajectory\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  timeout(function() rexp(1, rate=1.0/ACUTE_MEAN)) %&gt;% \n  log_(function() {paste(\"Acute Los complete \", now(env))}) %&gt;% \n  timeout(function() runif(n=1, min=REHAB_MIN, max=REHAB_MAX)) %&gt;% log_(function() {paste(\"Rehab Los complete \", now(env))})\n\nenv %&gt;% \n  # add 5 arrivals all at the same time.\n  add_generator(\"patient\", patient, at(0, 0, 0, 0, 0))\n\nsimmer environment: Experiment_1 | now: 0 | next: 0\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 0 }\n\nenv %&gt;%run() %&gt;% \n  invisible\n\n1.22214: patient3: Acute Los complete  1.2221407443285\n6.34678: patient0: Acute Los complete  6.34677797708443\n9.07171: patient2: Acute Los complete  9.07171320915222\n15.1417: patient4: Acute Los complete  15.1416521370411\n21.1486: patient1: Acute Los complete  21.1486480683088\n24.9755: patient3: Rehab Los complete  24.9754695647862\n59.8949: patient4: Rehab Los complete  59.8948675931897\n64.0513: patient0: Rehab Los complete  64.0512768532035\n69.9009: patient2: Rehab Los complete  69.9009241715539\n82.8909: patient1: Rehab Los complete  82.8909444257151\n\n\n\n\n\nHere we limit the model to simulated 3 patients that all arrive as the unit opens. Although arrival times are the same we can see that the acute length of stay and rehab length of stay quickly goes out of sync i.e.¬†we have introduced noise between experiments that is nothing to do with the variation in the number of patients. Let‚Äôs take patient 0 as an example.\nIn experiment 1:\n\nExits acute treatment at 6.3\nExits rehab treatment at 64.1\n\nIn experiment 2:\n\nExits acute treatment at 6.3\nExits rehab treatment at 55.1\n\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_2\") \n\n# setup simple patient trajectory\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  timeout(function() rexp(1, rate=1.0/ACUTE_MEAN)) %&gt;% \n  log_(function() {paste(\"Acute Los complete \", now(env))}) %&gt;% \n  timeout(function() runif(n=1, min=REHAB_MIN, max=REHAB_MAX)) %&gt;% \n  log_(function() {paste(\"Rehab Los complete \", now(env))})\n\nenv %&gt;% \n  # now limit to 3 patients.\n  add_generator(\"patient\", patient, at(0, 0, 0))\n\nsimmer environment: Experiment_2 | now: 0 | next: 0\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 0 }\n\nenv %&gt;%run() %&gt;% \n  invisible\n\n6.34678: patient0: Acute Los complete  6.34677797708443\n9.07171: patient2: Acute Los complete  9.07171320915222\n21.1486: patient1: Acute Los complete  21.1486480683088\n44.902: patient1: Rehab Los complete  44.9019768887665\n55.088: patient0: Rehab Los complete  55.0880146705431\n71.95: patient2: Rehab Los complete  71.9499536608346\n\n\n\n\n\n\nFinally we demonstrate that the effect is still observed across two arrivals that vary exponentially distributed inter-arrival times. We will run two new experiments. In the first IAT is 10 minutes. The second experiment increases the intensity of arrivals to an IAT of 9.0 minutes.\nFollow patient 0 through the system. You should see that the time rehabilitation ends is different. As a single stream of random numbers was used, we were unable to control the order in which these were used to generate samples from the distributions.\n\n\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_1\") \n\n# setup simple patient trajectory\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  timeout(function() rexp(1, rate=1.0/ACUTE_MEAN)) %&gt;% \n  log_(function() {paste(\"Acute Los complete \", now(env))}) %&gt;% \n  timeout(function() runif(n=1, min=REHAB_MIN, max=REHAB_MAX)) %&gt;% \n  log_(function() {paste(\"Rehab Los complete \", now(env))})\n\nenv %&gt;% \n  # expontially distr arrivals mean IAT = 10.0\n  add_generator(\"patient\", patient, function() rexp(1, rate=1.0/10.0))\n\nsimmer environment: Experiment_1 | now: 0 | next: 0\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 0 }\n\nenv %&gt;%\n  run(80) %&gt;% \n  invisible\n\n6.04042: patient1: Acute Los complete  6.04041924002745\n19.5976: patient2: Acute Los complete  19.5975513742415\n23.132: patient0: Acute Los complete  23.1320161861477\n23.4059: patient4: Acute Los complete  23.4059183199346\n29.7937: patient1: Rehab Los complete  29.7937480604851\n33.4439: patient5: Acute Los complete  33.4438912374584\n47.1482: patient0: Rehab Los complete  47.1481770882493\n51.7825: patient3: Acute Los complete  51.7824703988288\n64.6466: patient2: Rehab Los complete  64.6465848395711\n67.0391: patient3: Rehab Los complete  67.0391124205333\n75.3861: patient8: Acute Los complete  75.3861047258868\n\n\n\n\n\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_4\") \n\n# setup simple patient trajectory\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  timeout(function() rexp(1, rate=1.0/ACUTE_MEAN)) %&gt;% \n  log_(function() {paste(\"Acute Los complete \", now(env))}) %&gt;% \n  timeout(function() runif(n=1, min=REHAB_MIN, max=REHAB_MAX)) %&gt;% log_(function() {paste(\"Rehab Los complete \", now(env))})\n\nenv %&gt;% \n  # expontially distr arrivals mean IAT = 9.0\n  add_generator(\"patient\", patient, function() rexp(1, rate=1.0/9.0))\n\nsimmer environment: Experiment_4 | now: 0 | next: 0\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 0 }\n\nenv %&gt;%\n  run(80) %&gt;% \n  invisible\n\n5.55859: patient1: Acute Los complete  5.55859139045756\n18.6425: patient2: Acute Los complete  18.6425468953891\n21.3259: patient4: Acute Los complete  21.3259217950846\n22.9337: patient0: Acute Los complete  22.9336793743638\n29.3119: patient1: Rehab Los complete  29.3119202109152\n30.2824: patient5: Acute Los complete  30.2823544688134\n45.3421: patient4: Rehab Los complete  45.3420826971862\n50.4173: patient3: Acute Los complete  50.4173363519025\n63.6916: patient2: Rehab Los complete  63.6915803607186\n65.8941: patient3: Rehab Los complete  65.8940558991984\n77.7669: patient11: Acute Los complete  77.7669003911744\n78.2806: patient6: Acute Los complete  78.2805844677742"
  },
  {
    "objectID": "02_model/03_r_sampling.html#imports",
    "href": "02_model/03_r_sampling.html#imports",
    "title": "Sampling in R",
    "section": "",
    "text": "library(simmer)\nlibrary(simmer.bricks)\nlibrary(magrittr)"
  },
  {
    "objectID": "02_model/03_r_sampling.html#constants",
    "href": "02_model/03_r_sampling.html#constants",
    "title": "Sampling in R",
    "section": "",
    "text": "SEED &lt;- 42\nACUTE_MEAN &lt;- 32.0\nREHAB_MIN &lt;- 15.0\nREHAB_MAX &lt;- 80.0"
  },
  {
    "objectID": "02_model/03_r_sampling.html#experiment-1",
    "href": "02_model/03_r_sampling.html#experiment-1",
    "title": "Sampling in R",
    "section": "",
    "text": "n_patients &lt;- 5\n\nset.seed(SEED)\nacute_los &lt;- rexp(n=n_patients, rate=1.0/ACUTE_MEAN)\nrehab_los &lt;- runif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX)\n\nprint(acute_los)\n\n[1]  6.346778 21.148648  9.071713  1.222141 15.141652\n\nprint(rehab_los)\n\n[1] 23.75333 57.70450 60.82921 44.75322 61.74230"
  },
  {
    "objectID": "02_model/03_r_sampling.html#experiment-2",
    "href": "02_model/03_r_sampling.html#experiment-2",
    "title": "Sampling in R",
    "section": "",
    "text": "We will now reset the random stream using the same seed and limit the number of patients simulated to 2.\nWhen we re-run the code we might expect to get\n\nAcute Los:\n6.346778 21.148648\nRehab Los:\n23.75333 57.70450\n\nBut we will see that this does not happen. This is because all sampling makes use of a pseudo random number stream that generates uniformly distribution numbers \\(U\\)‚Äôs between 0 and 1. When only 1 stream is used for all sampling we can end up with lots of noise between experiments simply because different \\(U\\)‚Äôs are used for the same patients.\n\nn_patients &lt;- 2\n\nset.seed(SEED)\nacute_los &lt;- rexp(n=n_patients, rate=1.0/ACUTE_MEAN)\nrehab_los &lt;- runif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX)\n\nprint(acute_los)\n\n[1]  6.346778 21.148648\n\nprint(rehab_los)\n\n[1] 56.71346 48.74124"
  },
  {
    "objectID": "02_model/03_r_sampling.html#force-the-order-of-sampling",
    "href": "02_model/03_r_sampling.html#force-the-order-of-sampling",
    "title": "Sampling in R",
    "section": "",
    "text": "To force the order of sampling within a single random number stream each patient must do their sampling upfront and in process order.\nBelow we re-run Experiments 1 and 2, but this time we make sure the process is sampled in order (acute then rehab) for each patient.\n\n\n\nn_patients &lt;- 3\n\nset.seed(SEED)\n\nfor (patient_i in 1:n_patients) {\n    print(paste(\"Patient \", patient_i))\n    print(paste(\"Acute \", rexp(n=1, rate=1.0/ACUTE_MEAN)))\n    print(paste(\"Rehab \", runif(n=1, min=REHAB_MIN, max=REHAB_MAX)))\n}\n\n[1] \"Patient  1\"\n[1] \"Acute  6.34677797708443\"\n[1] \"Rehab  68.9790956943762\"\n[1] \"Patient  2\"\n[1] \"Acute  9.07171320915222\"\n[1] \"Rehab  48.7412366934586\"\n[1] \"Patient  3\"\n[1] \"Acute  15.1416521370411\"\n[1] \"Rehab  23.7533288204577\"\n\n\n\n\n\n\nn_patients &lt;- 2\n\nset.seed(SEED)\n\nfor (patient_i in 1:n_patients) {\n    print(paste(\"Patient \", patient_i))\n    print(paste(\"Acute \", rexp(n=1, rate=1.0/ACUTE_MEAN)))\n    print(paste(\"Rehab \", runif(n=1, min=REHAB_MIN, max=REHAB_MAX)))\n}\n\n[1] \"Patient  1\"\n[1] \"Acute  6.34677797708443\"\n[1] \"Rehab  68.9790956943762\"\n[1] \"Patient  2\"\n[1] \"Acute  9.07171320915222\"\n[1] \"Rehab  48.7412366934586\""
  },
  {
    "objectID": "02_model/03_r_sampling.html#a-simmer-model",
    "href": "02_model/03_r_sampling.html#a-simmer-model",
    "title": "Sampling in R",
    "section": "",
    "text": "By default simmer will be affected by the single random stream for all sampling. This is because in a DES sampling will not occur in process order like we saw above. The numbers generated will vary depending on when events are scheduled to take place.\nWe will first consider this in experiments where we control the exact number of arrivals. In these experiments we will not use resources. This means that there is no impact on the model due to queuing if we increase or decrease the number of arrivals to the model.\n\nTo simplify output we display the time patients exit acute and rehab activities.\n\n\n\n\n# set the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_1\") \n\n# setup simple patient trajectory\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  timeout(function() rexp(1, rate=1.0/ACUTE_MEAN)) %&gt;% \n  log_(function() {paste(\"Acute Los complete \", now(env))}) %&gt;% \n  timeout(function() runif(n=1, min=REHAB_MIN, max=REHAB_MAX)) %&gt;% log_(function() {paste(\"Rehab Los complete \", now(env))})\n\nenv %&gt;% \n  # add 5 arrivals all at the same time.\n  add_generator(\"patient\", patient, at(0, 0, 0, 0, 0))\n\nsimmer environment: Experiment_1 | now: 0 | next: 0\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 0 }\n\nenv %&gt;%run() %&gt;% \n  invisible\n\n1.22214: patient3: Acute Los complete  1.2221407443285\n6.34678: patient0: Acute Los complete  6.34677797708443\n9.07171: patient2: Acute Los complete  9.07171320915222\n15.1417: patient4: Acute Los complete  15.1416521370411\n21.1486: patient1: Acute Los complete  21.1486480683088\n24.9755: patient3: Rehab Los complete  24.9754695647862\n59.8949: patient4: Rehab Los complete  59.8948675931897\n64.0513: patient0: Rehab Los complete  64.0512768532035\n69.9009: patient2: Rehab Los complete  69.9009241715539\n82.8909: patient1: Rehab Los complete  82.8909444257151\n\n\n\n\n\nHere we limit the model to simulated 3 patients that all arrive as the unit opens. Although arrival times are the same we can see that the acute length of stay and rehab length of stay quickly goes out of sync i.e.¬†we have introduced noise between experiments that is nothing to do with the variation in the number of patients. Let‚Äôs take patient 0 as an example.\nIn experiment 1:\n\nExits acute treatment at 6.3\nExits rehab treatment at 64.1\n\nIn experiment 2:\n\nExits acute treatment at 6.3\nExits rehab treatment at 55.1\n\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_2\") \n\n# setup simple patient trajectory\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  timeout(function() rexp(1, rate=1.0/ACUTE_MEAN)) %&gt;% \n  log_(function() {paste(\"Acute Los complete \", now(env))}) %&gt;% \n  timeout(function() runif(n=1, min=REHAB_MIN, max=REHAB_MAX)) %&gt;% \n  log_(function() {paste(\"Rehab Los complete \", now(env))})\n\nenv %&gt;% \n  # now limit to 3 patients.\n  add_generator(\"patient\", patient, at(0, 0, 0))\n\nsimmer environment: Experiment_2 | now: 0 | next: 0\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 0 }\n\nenv %&gt;%run() %&gt;% \n  invisible\n\n6.34678: patient0: Acute Los complete  6.34677797708443\n9.07171: patient2: Acute Los complete  9.07171320915222\n21.1486: patient1: Acute Los complete  21.1486480683088\n44.902: patient1: Rehab Los complete  44.9019768887665\n55.088: patient0: Rehab Los complete  55.0880146705431\n71.95: patient2: Rehab Los complete  71.9499536608346"
  },
  {
    "objectID": "02_model/03_r_sampling.html#simmer-and-random-arrivals",
    "href": "02_model/03_r_sampling.html#simmer-and-random-arrivals",
    "title": "Sampling in R",
    "section": "",
    "text": "Finally we demonstrate that the effect is still observed across two arrivals that vary exponentially distributed inter-arrival times. We will run two new experiments. In the first IAT is 10 minutes. The second experiment increases the intensity of arrivals to an IAT of 9.0 minutes.\nFollow patient 0 through the system. You should see that the time rehabilitation ends is different. As a single stream of random numbers was used, we were unable to control the order in which these were used to generate samples from the distributions.\n\n\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_1\") \n\n# setup simple patient trajectory\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  timeout(function() rexp(1, rate=1.0/ACUTE_MEAN)) %&gt;% \n  log_(function() {paste(\"Acute Los complete \", now(env))}) %&gt;% \n  timeout(function() runif(n=1, min=REHAB_MIN, max=REHAB_MAX)) %&gt;% \n  log_(function() {paste(\"Rehab Los complete \", now(env))})\n\nenv %&gt;% \n  # expontially distr arrivals mean IAT = 10.0\n  add_generator(\"patient\", patient, function() rexp(1, rate=1.0/10.0))\n\nsimmer environment: Experiment_1 | now: 0 | next: 0\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 0 }\n\nenv %&gt;%\n  run(80) %&gt;% \n  invisible\n\n6.04042: patient1: Acute Los complete  6.04041924002745\n19.5976: patient2: Acute Los complete  19.5975513742415\n23.132: patient0: Acute Los complete  23.1320161861477\n23.4059: patient4: Acute Los complete  23.4059183199346\n29.7937: patient1: Rehab Los complete  29.7937480604851\n33.4439: patient5: Acute Los complete  33.4438912374584\n47.1482: patient0: Rehab Los complete  47.1481770882493\n51.7825: patient3: Acute Los complete  51.7824703988288\n64.6466: patient2: Rehab Los complete  64.6465848395711\n67.0391: patient3: Rehab Los complete  67.0391124205333\n75.3861: patient8: Acute Los complete  75.3861047258868\n\n\n\n\n\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_4\") \n\n# setup simple patient trajectory\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  timeout(function() rexp(1, rate=1.0/ACUTE_MEAN)) %&gt;% \n  log_(function() {paste(\"Acute Los complete \", now(env))}) %&gt;% \n  timeout(function() runif(n=1, min=REHAB_MIN, max=REHAB_MAX)) %&gt;% log_(function() {paste(\"Rehab Los complete \", now(env))})\n\nenv %&gt;% \n  # expontially distr arrivals mean IAT = 9.0\n  add_generator(\"patient\", patient, function() rexp(1, rate=1.0/9.0))\n\nsimmer environment: Experiment_4 | now: 0 | next: 0\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 0 }\n\nenv %&gt;%\n  run(80) %&gt;% \n  invisible\n\n5.55859: patient1: Acute Los complete  5.55859139045756\n18.6425: patient2: Acute Los complete  18.6425468953891\n21.3259: patient4: Acute Los complete  21.3259217950846\n22.9337: patient0: Acute Los complete  22.9336793743638\n29.3119: patient1: Rehab Los complete  29.3119202109152\n30.2824: patient5: Acute Los complete  30.2823544688134\n45.3421: patient4: Rehab Los complete  45.3420826971862\n50.4173: patient3: Acute Los complete  50.4173363519025\n63.6916: patient2: Rehab Los complete  63.6915803607186\n65.8941: patient3: Rehab Los complete  65.8940558991984\n77.7669: patient11: Acute Los complete  77.7669003911744\n78.2806: patient6: Acute Los complete  78.2805844677742"
  },
  {
    "objectID": "02_model/01_model.html",
    "href": "02_model/01_model.html",
    "title": "Model code",
    "section": "",
    "text": "Note: we are calculating KPIs using our own code here, but you can also use simmer.plot. Help with install of simmer.plot (igraph installation is the actual issue) on Linux based systems: https://r.igraph.org/articles/installation-troubleshooting#cannot-compile-igraph-from-sources-on-linux\n\nIf you make use of conda environments (via Anaconda/mini-conda/mini-forge/mamba), remember to conda deactivate before installation.\n\n\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nsuppressMessages(library(simmer.plot))\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))\nsuppressMessages(library(Rlab))\nsuppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))\n\noptions(dplyr.summarise.inform = FALSE)"
  },
  {
    "objectID": "02_model/01_model.html#imports",
    "href": "02_model/01_model.html#imports",
    "title": "Model code",
    "section": "",
    "text": "Note: we are calculating KPIs using our own code here, but you can also use simmer.plot. Help with install of simmer.plot (igraph installation is the actual issue) on Linux based systems: https://r.igraph.org/articles/installation-troubleshooting#cannot-compile-igraph-from-sources-on-linux\n\nIf you make use of conda environments (via Anaconda/mini-conda/mini-forge/mamba), remember to conda deactivate before installation.\n\n\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nsuppressMessages(library(simmer.plot))\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))\nsuppressMessages(library(Rlab))\nsuppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))\n\noptions(dplyr.summarise.inform = FALSE)"
  },
  {
    "objectID": "02_model/01_model.html#default-values-and-constants",
    "href": "02_model/01_model.html#default-values-and-constants",
    "title": "Model code",
    "section": "2. Default values and constants",
    "text": "2. Default values and constants\n\n2.1 Distribution parameters\n\n#' Mean and Variance of the underlying Normal Distribution\n#' \n#' @description\n#' `normal_moments_from_lognormal` calculates the mu and sigma\n#' of the normal distribution underlying a lognormal\n#' mean and standard \n#'\n#' @details\n#' `rlnorm` from `stats` is designed to sample from the lognormal distribution. \n#' The parameters is expects are moments of the underlying normal distribution\n#' Using sample mean and standard deviation this function calculates \n#' the mu and sigma of the normal distribution. source: https://blogs.sas.com/content/iml/2014/06/04/simulate-lognormal-data-with-specified-mean-and-variance.html\n#' \n#' @param mean A number. Sample mean.\n#' @param stdev A number. Sample standard deviation\n#' @returns A list \nnormal_moments_from_lognormal &lt;- function(mean, std){\n  phi &lt;- sqrt(std^2 + mean^2)\n  mu &lt;- log(mean**2/phi)\n  sigma &lt;- sqrt(log(phi^2/mean^2))\n  return(list(\"mu\" = mu, \"sigma\" = sigma))\n}\n\n\n# sign-in/triage parameters\nDEFAULT_TRIAGE_MEAN &lt;- 3.0\n\n# registration parameters (lognormal distribution)\nDEFAULT_REG_PARAMS &lt;- normal_moments_from_lognormal(5.0, sqrt(2.0))\n\n# examination parameters\nDEFAULT_EXAM_PARAMS = list(mean=16.0, var=3.0)\n\n# trauma/stabilisation\nDEFAULT_TRAUMA_MEAN &lt;- 90.0\n\n# Trauma treatment (lognormal distribution)\nDEFAULT_TRAUMA_TREATMENT_PARAMS &lt;- normal_moments_from_lognormal(30.0, sqrt(4.0))\n\n# Non trauma treatment (lognormal distribution)\nDEFAULT_NON_TRAUMA_TREATMENT_PARAMS &lt;- normal_moments_from_lognormal(13.3, sqrt(2.0))\n\n# prob patient requires treatment given trauma\nDEFAULT_NON_TRAUMA_TREAT_P &lt;- 0.60\n\n# proportion of patients triaged as trauma\nDEFAULT_PROB_TRAUMA &lt;- 0.12\n\n\n\n2.2 Time dependent arrival rate data\nThe data for arrival rates varies between clinic opening at 6am and closure at 12am.\n\n# data are held in the Github repo and loaded from there.\nNSPP_PATH = 'https://raw.githubusercontent.com/TomMonks/open-science-for-sim/main/src/notebooks/01_foss_sim/data/ed_arrivals.csv'\n\ncsv_data &lt;- getURL(NSPP_PATH)\ndf &lt;- read.csv(text=csv_data)\n\n# lock in order of time of day for bar chart display\ndf$period &lt;- factor(df$period, levels = df$period)\n\nggplot(data=df, aes(x=period, y=arrival_rate)) +\n  geom_bar(stat=\"identity\", fill=\"steelblue\") + \n  theme(axis.text.x = element_text(angle = 90, \n                                   vjust = 0.5, \n                                   hjust=1)) +\n  xlab(\"Hour of day\") + \n  ylab(\"Mean arrivals (patients/hr)\")\n\n\n\n\n\n\n2.3 Resource Counts\nInteger count variables representing the number of resources at each activity in the process\n\nDEFAULT_N_TRIAGE &lt;- 1\nDEFAULT_N_REG &lt;- 1\nDEFAULT_N_EXAM &lt;- 3\n\n# stabilisation rooms\nDEFAULT_N_TRAUMA &lt;- 10000\n\n# Non-trauma cubicles\nDEFAULT_NON_TRAUMA_CUBICLES &lt;- 1\n\n# trauma pathway cubicles\nDEFAULT_TRAUMA_CUBICLES &lt;- 1\n\n\n\n2.4 Simulation model run settings\n\n# Random seed - this will be investigated for CRN\nSEED &lt;- 42\n\n# default results collection period\nDEFAULT_RESULTS_COLLECTION_PERIOD &lt;- 60 * 19\n\n# number of replications.\nDEFAULT_N_REPS &lt;- 5\n\n# Show the a trace of simulated events\n# 1 = show, 0 = do not show.\nLOG_LEVEL &lt;- 1"
  },
  {
    "objectID": "02_model/01_model.html#functions",
    "href": "02_model/01_model.html#functions",
    "title": "Model code",
    "section": "3. Functions",
    "text": "3. Functions\nLoad and format data\n\nload_arrival_data &lt;- function(path=NSPP_PATH){\n  csv_data &lt;- getURL(NSPP_PATH)\n  df &lt;- read.csv(text=csv_data)\n  \n  # arrivals per minute...\n  df$arrival_rate2 &lt;- df$arrival_rate/60.0\n  \n  # create 60 minute increments for period\n  df$period = seq(0, (nrow(df)-1)*60, by=60)\n  return(df)\n}\n\n\n#' Sample a patient type\n#' \n#' @description\n#' `sample_arrival_type` samples if a patient type is trauma or non-trauma\n#' with a given probability.\n#'\n#' @details\n#' The function uses the Bernouli distribution (Rlab) to sample\n#' if a patient is Trauma or Non-Trauma.  The return values are \n#' 1 = Trauma, 2 = Non-trauma.\n#' @param p A number: the probability a patient has trauma on arrival\nsample_arrival_type &lt;- function(p, n=1){\n  ifelse(rbern(n, prob = DEFAULT_PROB_TRAUMA) == 1, 1, 2)\n}\n\n\n#' Sample a if a non-trauma patient requires treatment\n#' \n#' @description\n#' `sample_nt_trauma_treatment` samples if a non-trauma patient\n#' requires cubicle treatment\n#'\n#' @details\n#' The function uses the Bernouli distribution (Rlab) to sample\n#' if a patient is requires treatment or not.  The return values are \n#' 1 = Treatment, 0 = No treatment\n#' @param p A number: The probability the patient requires treatment\nsample_nt_trauma_treatment &lt;- function(p){\n  ifelse(rbern(1, prob = p) == 1, 1, 0)\n}\n\nSampling from a non-stationary poisson process using thinning\n\nnspp_thinning &lt;- function(simulation_time, data, debug=FALSE){\n  \n  # calc time interval: assumes intervals are of equal length\n  interval &lt;- data$period[2] - data$period[1]\n  \n  # maximum arrival rate (smallest time between arrivals)\n  lambda_max &lt;- max(data$arrival_rate2)\n\n  while(TRUE){\n    # get time bucket (row of dataframe to use)\n    t &lt;- floor(simulation_time / interval) %% nrow(data) + 1\n    lambda_t &lt;- data$arrival_rate2[t]\n    \n    # set to a large number so that at least 1 sample is taken\n    u &lt;- Inf\n    rejects &lt;- -1\n    \n    # running total of time until next arrival\n    inter_arrival_time &lt;- 0.0\n    \n    # reject proportionate to lambda_t / lambda_max\n    ratio &lt;- lambda_t / lambda_max\n    while(u &gt;= ratio){\n      rejects &lt;- rejects + 1\n      # sample using max arrival rate\n      inter_arrival_time &lt;- inter_arrival_time + rexp(1, lambda_max)\n      u &lt;- runif(1, 0.0, 1.0)\n    }\n    \n    if(debug){\n      print({paste(\"Time:\", simulation_time, \n                   \" Rejections:\", rejects, \n                   \" t:\", t, \n                   \" lambda_t:\", lambda_t, \n                   \" IAT:\", inter_arrival_time)})\n    }\n      \n    return(inter_arrival_time)\n  }\n}"
  },
  {
    "objectID": "02_model/01_model.html#model-parameterisation",
    "href": "02_model/01_model.html#model-parameterisation",
    "title": "Model code",
    "section": "4. Model parameterisation",
    "text": "4. Model parameterisation\nThe model is setup to be created from a set of functions that return trajectories. Each function accepts a list that contains all parameters to configure the simulation model. Here we create the list and pre-populate it using default values.\n\ncreate_experiment &lt;- function(n_triage_bays=DEFAULT_N_TRIAGE,\n                              n_reg_clerks=DEFAULT_N_REG,\n                              n_exam_rooms=DEFAULT_N_EXAM,\n                              n_trauma_rooms=DEFAULT_N_TRAUMA,\n                              n_non_trauma_cubicles=DEFAULT_NON_TRAUMA_CUBICLES,\n                              n_trauma_cubicles=DEFAULT_TRAUMA_CUBICLES,\n                              triage_mean=DEFAULT_TRIAGE_MEAN,\n                              stabilisation_mean=DEFAULT_TRAUMA_MEAN,\n                              trauma_treat_params=DEFAULT_TRAUMA_TREATMENT_PARAMS,\n                              reg_params=DEFAULT_REG_PARAMS,\n                              exam_params=DEFAULT_EXAM_PARAMS,\n                              prob_non_trauma_treat=DEFAULT_NON_TRAUMA_TREAT_P,\n                              nontrauma_treat_params=DEFAULT_NON_TRAUMA_TREATMENT_PARAMS,\n                              prob_trauma=DEFAULT_PROB_TRAUMA,\n                              arrival_data_path=NSPP_PATH,\n                              log_level=LOG_LEVEL) {\n  \n  # load arrival data\n  arrival_data &lt;- load_arrival_data(path=arrival_data_path)\n  \n  # create list of parameters\n  experiment &lt;- list(n_triage_bays=n_triage_bays,\n                    n_reg_clerks=n_reg_clerks,\n                    n_exam_rooms=n_exam_rooms,\n                    n_trauma_rooms=n_trauma_rooms,\n                    n_non_trauma_cubicles=n_non_trauma_cubicles,\n                    n_trauma_cubicles=n_trauma_cubicles,\n                    triage_mean=triage_mean,\n                    stabilisation_mean=stabilisation_mean,\n                    trauma_treat_params=trauma_treat_params,\n                    reg_params=reg_params,\n                    exam_params=exam_params,\n                    prob_non_trauma_treat=prob_non_trauma_treat,\n                    nontrauma_treat_params=nontrauma_treat_params,\n                    prob_trauma=prob_trauma,\n                    arrival_data=arrival_data,\n                    log_level=log_level)\n  \n  return(experiment)\n}"
  },
  {
    "objectID": "02_model/01_model.html#patient-trajectories",
    "href": "02_model/01_model.html#patient-trajectories",
    "title": "Model code",
    "section": "5. Patient Trajectories",
    "text": "5. Patient Trajectories\nThe DES package simmer uses the concept of a trajectory to model a process for a particular patient type. In the urgent care centre example trajectories allow us to model separate trauma and non-trauma processes. Note that different trajectories can share common resources.\nThe simmer terminology for using resources and engaging in activities is easy to read:\n\nseize - queue and take a resource when it is available.\ntimeout - a process delay (e.g.¬†treatment or diagnostics)\nrelease - release a resource.\n\nsimmer also provides a way to set an attribute of the trajectory using set_attribute. This is useful for storing timing information to display in a log: for example when a patient begins waiting for a resource (access via now(env)).\n\nImportant notes:\n\nThe function log_ is used in combination with function() paste to provide a dynamic simulation trace to the R console.\nSampling code should look as follows:\n\ntimeout(task = function() rexp(1, 3.0)) %&gt;%\n\nThe keyword function() must be included for dynamic sampling for each patient. Omitting function() means that it is evaluated once at the time the trajectory is created.\n\n\n\n5.1. Trauma Patients\n\nWe wrap the trajectory in a function called create_trauma_pathway. This allows us to pass an argument exp that can parameterise the trajectory for use in a discrete experiment.\n\n\ncreate_trauma_pathway &lt;- function(exp){\n    \n    trauma_pathway &lt;- trajectory(name=\"trauma_pathway\") %&gt;%\n      set_attribute(\"patient_type\", 1) %&gt;%\n      # log patient arrival\n      log_(function() {paste(\"**Trauma arrival\")}, level=1) %&gt;% \n      \n      # triage \n      set_attribute(\"start_triage_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"triage_bay\", function() rexp(1, 1/exp$triage_mean)) %&gt;%\n      log_(function() {paste(\"(T) Triage wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n           level=1) %&gt;%\n      \n      # request trauma room for stabilization\n      set_attribute(\"start_trauma_room_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"trauma_room\", function() rexp(1, 1/exp$stabilisation_mean)) %&gt;%\n      log_(function() {paste(\"(T) Trauma room wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_trauma_room_wait\"))},\n           level=1) %&gt;%\n      \n      # request treatment cubicle\n      set_attribute(\"start_trauma_treat_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"trauma_treat_cubicle\", function() rlnorm(1, exp$trauma_treat_params$mu,\n                                                      exp$trauma_treat_params$sigma)) %&gt;%\n      log_(function() {paste(\"********************(T) Trauma treatment cubicle wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_trauma_treat_wait\"))},\n           level=1) %&gt;% \n    \n      # store the total time in system \n      set_attribute(\"total_time\", \n                    function() {now(exp$env) - get_attribute(exp$env, \"start_triage_wait\")})\n    \n  return(trauma_pathway)\n}\n\n\n\n5.2 Non-trauma patients\n\ncreate_nt_cubicle_treatment &lt;- function(exp){\n\n  nt_cubicle_treatment &lt;- trajectory() %&gt;% \n    log_(function() {paste(\"NT patient requirement treatment\")},\n         level=1) %&gt;% \n    seize(resource=\"nontrauma_treat_cubicle\", amount=1) %&gt;% \n    \n    timeout(task = function() rlnorm(1, exp$nontrauma_treat_params$mu,                                                     exp$nontrauma_treat_params$sigma)) %&gt;%\n    release(resource = \"nontrauma_treat_cubicle\", amount = 1) %&gt;% \n    log_(function() {paste(\"NT treatment complete\")},\n     level=1) %&gt;% \n  return(nt_cubicle_treatment)\n}\n\n\ncreate_non_trauma_pathway &lt;- function(exp){\n  # log messages\n  ARRIVAL_MSG = \"**Non-Trauma arrival**\"\n  TRIAGE_MSG = \"(NT) Triage wait time:\"\n  REG_MSG = \"Reg wait time:\"\n  EXAM_MSG = \"Exam wait time:\"\n  EXIT_MSG = \"NT Total time in system:\"\n  \n  # optional trajectory for proportion of patients that requirement treatment\n  nt_cubicle_treatment &lt;- create_nt_cubicle_treatment(exp)\n  \n  non_trauma_pathway &lt;- trajectory(name=\"non_trauma_pathway\") %&gt;%\n    set_attribute(\"patient_type\", 2) %&gt;%\n    # log non_trauma arrival\n    log_(function() {paste(ARRIVAL_MSG)}, level=1) %&gt;% \n    \n    # store start of waiting time for log calculations\n    set_attribute(\"start_triage_wait\", function() {now(exp$env)}) %&gt;%\n    # queue and use triage bay\n    visit(\"triage_bay\", function() rexp(1, 1/exp$triage_mean)) %&gt;%\n    log_(function() {paste(TRIAGE_MSG, now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %&gt;%\n    \n    # queue and use registration clerk\n    set_attribute(\"start_reg_wait\", function() {now(exp$env)}) %&gt;%\n    visit(\"registration_clerk\", function() rlnorm(1, exp$reg_params$mu, \n                                                  exp$reg_params$sigma)) %&gt;%\n    log_(function() {paste(REG_MSG, now(exp$env) - get_attribute(exp$env, \"start_reg_wait\"))},\n         level=1) %&gt;%\n    \n    # queue and use examination room\n    set_attribute(\"start_exam_wait\", function() {now(exp$env)}) %&gt;%\n    visit(\"examination_room\",  function() rnorm(1, exp$exam_params$mean, \n                                                sqrt(exp$exam_params$var))) %&gt;%\n    log_(function() {paste(EXAM_MSG, now(exp$env) - get_attribute(exp$env, \"start_exam_wait\"))},\n         level=1) %&gt;%\n    \n    # a Proportion of patients require treatment in a cubicle\n    branch (\n      function() sample_nt_trauma_treatment(exp$prob_non_trauma_treat), continue=T,\n      nt_cubicle_treatment\n    ) %&gt;% \n    log_(function() {paste(EXIT_MSG, now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %&gt;% \n    # store the total time in system \n    set_attribute(\"total_time\", \n                    function() {now(exp$env) - get_attribute(exp$env, \"start_triage_wait\")})\n  \n  return(non_trauma_pathway)\n}"
  },
  {
    "objectID": "02_model/01_model.html#modelling-patient-arrivals",
    "href": "02_model/01_model.html#modelling-patient-arrivals",
    "title": "Model code",
    "section": "6. Modelling patient arrivals",
    "text": "6. Modelling patient arrivals\nPatients arrive a the urgent treatment centre following a time dependent process. When patients arrive they are classified as trauma or non-trauma.\nTo modify the classification of patients we will use a trajectory that uses the `branch` function from simmer.\nThe function `sample_arrival_type` returns a 1 (trauma) or 2 (non-trauma). This is used to select the appropriate patient trajectory.\n\ncreate_arrival_generator &lt;- function(exp){\n  \n  DEPART_MSG &lt;- \"A patient has departed the UTC\"\n  \n  # create and parameterise the trauma pathway trajectory\n  trauma_pathway &lt;- create_trauma_pathway(exp)\n  \n  # create and parameterise the non-trauma pathway trajectory\n  non_trauma_pathway &lt;- create_non_trauma_pathway(exp)\n  \n  patient_arrival &lt;- trajectory() %&gt;%\n    branch(\n      function() sample_arrival_type(exp$prob_trauma), continue=T,\n        trauma_pathway,\n        non_trauma_pathway\n    ) %&gt;%\n    log_(function() {paste(DEPART_MSG)},level=1) %&gt;% \n    set_attribute(\"departed\", 1)\n  \n  return(patient_arrival)\n}"
  },
  {
    "objectID": "02_model/01_model.html#single-run-of-the-model",
    "href": "02_model/01_model.html#single-run-of-the-model",
    "title": "Model code",
    "section": "7. Single run of the model",
    "text": "7. Single run of the model\n\nWork in progress\n\n\nsingle_run &lt;- function(env, exp, \n                       rep_number=1, \n                       run_length=DEFAULT_RESULTS_COLLECTION_PERIOD, \n                       debug_arrivals=FALSE){\n  # add the simmer environment to the experiment list.\n  exp &lt;- c(exp, env=env) \n  \n  # Create the arrivals generator\n  arrival_gen &lt;- create_arrival_generator(exp)\n  \n  # create model and run.\n  env %&gt;% \n    add_resource(\"triage_bay\", exp$n_triage_bays) %&gt;%\n    add_resource(\"registration_clerk\", exp$n_reg_clerks) %&gt;%\n    add_resource(\"examination_room\", exp$n_exam_rooms) %&gt;%\n    add_resource(\"trauma_room\", exp$n_trauma_rooms) %&gt;%\n    add_resource(\"trauma_treat_cubicle\", exp$n_trauma_cubicles) %&gt;%\n    add_resource(\"nontrauma_treat_cubicle\", exp$n_non_trauma_cubicles) %&gt;%\n    add_generator(\"Patient\", arrival_gen, \n                  function() nspp_thinning(now(env), exp$arrival_data, \n                                           debug=debug_arrivals),\n                  mon=2) %&gt;% \n    run(until=run_length)\n  \n  # return environment and all of its results.\n  return(env)\n}\n\nScript to conduct single run of the model\n\nNote that the environment is created outside of the single_run function. This is to separate the creation of the environment from the run function call. The reason is so that the now(env) function will work correctly in the nspp_thinning sampling function (if we do not separate then the same time is always passed to the function).\n\n\nset.seed(SEED)\nexp &lt;- create_experiment(log_level=0)\ntreat_sim &lt;- simmer(\"TreatSim\", log_level=exp$log_level)\ntreat_sim &lt;- single_run(treat_sim, exp)\nprint(\"Simulation Complete.\")\n\n[1] \"Simulation Complete.\""
  },
  {
    "objectID": "02_model/01_model.html#multiple-replications",
    "href": "02_model/01_model.html#multiple-replications",
    "title": "Model code",
    "section": "8. Multiple replications",
    "text": "8. Multiple replications\n\nN_REPS &lt;- 50\n\nset.seed(42)\n\n# note unlike in simmer documentation we use a traditional for loop\n# instead of lapply. This allows us to separate env creation\n# from run and preserve the environment interaction between NSPP \n# and current sim time.\n# TO DO: look again -&gt; can treat_sim be created inside single_run()\nprint(\"running replications...\")\n\n[1] \"running replications...\"\n\nreps = vector()\nfor(rep in 1:N_REPS){\n  exp &lt;- create_experiment(log_level=0)\n  treat_sim &lt;- simmer(\"TreatSim\", log_level=exp$log_level)\n  treat_sim &lt;- single_run(treat_sim, exp)\n  # store the latest simulation enviornment and its results.\n  reps &lt;- c(reps, treat_sim)\n}\nprint(\"Complete.\")\n\n[1] \"Complete.\""
  },
  {
    "objectID": "02_model/01_model.html#results-analysis",
    "href": "02_model/01_model.html#results-analysis",
    "title": "Model code",
    "section": "9. Results analysis",
    "text": "9. Results analysis\nAnalysis of simmer results is achieved using a mix of statistics collected automatically and custom attributes set by the modeller during the run.\nIn general, we follow a typical strategy in a simulation study. We calculate the mean Key Performance Indicator (KPI) seen during an individual replication of the model (e.g.¬†waiting time for triage and utilisation of the the triage rooms). This is repeated for all replications and the distribution of results can be visualised or we use a summary measure such as the mean.\nBelow we construct a summary table of results providing the mean of 16 KPIs.\n\nCode quality is a work in progress. üòÉ\n\n\narrivals_by_replication &lt;- function(envs){\n  results &lt;- vector()\n  for(env in envs){\n    results &lt;- c(results, get_n_generated(env, \"Patient\"))\n  }\n  return(data.frame(results))\n}\n\n\nget_resource_counts &lt;- function(exp) {\n  resource = c(\"triage_bay\", \n                \"registration_clerk\", \n                \"examination_room\",\n                \"trauma_room\",\n                \"trauma_treat_cubicle\",\n                \"nontrauma_treat_cubicle\")\n  \n  resource_counts = c(exp$n_triage_bays,\n                      exp$n_reg_clerks,\n                      exp$n_exam_rooms,\n                      exp$n_trauma_rooms,\n                      exp$n_trauma_cubicles,\n                      exp$n_non_trauma_cubicles)\n  \n  df_resource &lt;- data.frame(resource)\n  df_resource$count &lt;- resource_counts\n  return(df_resource)\n}\n\nFunctions to calculate KPIs from custom attributes\n\n# mean time in the system and throughput\ncalc_kpi_from_attributes_for_rep &lt;- function(rep){\n  \n  # get attributes\n  att &lt;- get_mon_attributes(reps)\n  # for speed - limit to replication number.\n  rep_att &lt;- subset(att[att$replication == rep,], select = c(name, key, value))\n  # long to wide format...\n  data_wide &lt;- spread(rep_att, key, value)\n  \n  # Patient type 1: trauma\n  # take the mean and ignore patients still in pathway\n  mean_time_1 = mean(data_wide[data_wide$patient_type == 1,]$total_time, na.rm = TRUE)\n  \n  # Patient type 2: non_trauma\n  # take the mean and ignore patients still in pathway\n  mean_time_2 = mean(data_wide[data_wide$patient_type == 2,]$total_time, na.rm = TRUE)\n  \n  # Throughput - discharges during opening hours.\n  throughput &lt;- sum(data_wide$departed, na.rm=TRUE)\n  \n  # store and return data.frame of results\n  rep_results &lt;- data.frame(\"05_total_time(non-trauma)\" = mean_time_2,\n                            \"08_total_time(trauma)\" = mean_time_1, \n                            \"09_throughput\"= throughput)\n  return(rep_results)\n}\n\ncalc_kpi_from_attributes &lt;- function(){\n  # calcs total time by patient type and total throughput\n  \n  # empty dataframe for attribute calculations.\n  att_results &lt;- data.frame(matrix(ncol = 3, nrow = 0))\n  colnames(att_results) &lt;- c(\"05_total_time(non-trauma)\", \"08_total_time(trauma)\", \"09_throughput\")\n\n  # add each rep separately as this works faster with pivot\n  for(rep in 1:N_REPS){\n    att_results &lt;- rbind(att_results, calc_kpi_from_attributes_for_rep(rep))\n  }\n\n  # return the KPIs by replications\n  return(att_results)\n}\n\n\ncreate_summary_table &lt;- function(reps, exp, dp=2){\n\n  # mean number of arrivals\n  arrival_counts &lt;- arrivals_by_replication(reps)\n  mean_arrivals &lt;- mean(arrival_counts$results)\n  arrival_df &lt;- data.frame(\"00_arrivals\", mean_arrivals)\n  names(arrival_df)&lt;-c(\"kpi\",\"mean\")\n\n  \n  # get results dataframe broken down by resource and replication.\n  arrivals &lt;- get_mon_arrivals(reps, per_resource=TRUE)\n  \n  # calculate waiting time\n  arrivals$waiting_time &lt;-arrivals$end_time - arrivals$start_time - arrivals$activity_time\n  # arrivals$waiting_time &lt;- round(arrivals$waiting_time, 2)\n  \n  cols &lt;- c(\"resource\", \"replication\")\n  summary_wait &lt;- arrivals %&gt;%\n    # mean waiting time in each replication\n    group_by(across(all_of(cols))) %&gt;%\n    summarise(rep_waiting_time=mean(waiting_time)) %&gt;% \n    # mean waiting time across replications\n    group_by(resource) %&gt;% \n    summarise(mean=mean(rep_waiting_time)) %&gt;% \n    mutate(resource=recode(resource,  \n                         'triage_bay'='01a_triage_wait', \n                         'registration_clerk'='02a_registration_wait',\n                         'examination_room'='03a_examination_wait',\n                         'nontrauma_treat_cubicle'='04a_treatment_wait(non_trauma)',\n                         'trauma_room'='06a_stabilisation_wait',\n                         'trauma_treat_cubicle'='07a_treatment_wait(trauma)')) %&gt;% \n    arrange(resource)\n  \n  \n  names(summary_wait)&lt;-c(\"kpi\",\"mean\")\n  \n  # utilisation calculation:\n  # simple calculation of total busy time / total scheduled resource time.\n  # where total scheduled time = n_resource * results collection period.\n  summary_util &lt;- arrivals %&gt;%\n    # mean waiting time in each replication\n    group_by(across(all_of(cols))) %&gt;%\n    summarise(in_use=sum(activity_time)) %&gt;% \n    arrange(resource)\n  \n  # add resource counts to table for calc\n  summary_util &lt;- merge(summary_util, get_resource_counts(exp), \n                        by=\"resource\", all=TRUE)\n  \n  # total in use / total scheduled time\n  summary_util$util = summary_util$in_use / (DEFAULT_RESULTS_COLLECTION_PERIOD * summary_util$count)  \n  \n  summary_util &lt;- summary_util %&gt;%\n    # mean waiting time in each replication\n    group_by(resource) %&gt;%\n    summarise(mean=mean(util)) %&gt;% \n    mutate(resource=recode(resource,  \n                         'triage_bay'='01b_triage_util', \n                         'registration_clerk'='02b_registration_util',\n                         'examination_room'='03b_examination_util',\n                         'nontrauma_treat_cubicle'='04b_treatment_util(non_trauma)',\n                         'trauma_room'='06b_stabilisation_util',\n                         'trauma_treat_cubicle'='07b_treatment_util(trauma)')) %&gt;% \n    arrange(resource)\n\n  names(summary_util) &lt;- c(\"kpi\",\"mean\")\n  \n  overall &lt;- bind_rows(arrival_df, summary_wait, summary_util) %&gt;% \n    arrange(kpi) \n  \n  ## KPIs calculated from attributes\n  # empty dataframe for attribute calculations.\n  att_results &lt;- calc_kpi_from_attributes()\n  mean_att_results &lt;- colMeans(att_results)\n\n  overall &lt;- overall %&gt;%\n    add_row(kpi=\"05_total_time(non-trauma)\", mean=mean_att_results[1]) %&gt;%\n    add_row(kpi=\"08_total_time(trauma)\", mean=mean_att_results[2]) %&gt;%\n    add_row(kpi=\"09_throughput\", mean=mean_att_results[3]) %&gt;%\n    arrange(kpi)\n  \n  # round and return\n  overall$mean &lt;- round(overall$mean, dp)\n  return(overall)\n}\n\n\nresults_summary &lt;- create_summary_table(reps, exp)\nresults_summary\n\n                              kpi   mean\n1                     00_arrivals 230.48\n2                 01a_triage_wait  34.05\n3                 01b_triage_util   0.60\n4           02a_registration_wait 107.45\n5           02b_registration_util   0.84\n6            03a_examination_wait  23.92\n7            03b_examination_util   0.84\n8  04a_treatment_wait(non_trauma) 139.57\n9  04b_treatment_util(non_trauma)   0.87\n10      05_total_time(non-trauma) 236.96\n11         06a_stabilisation_wait   0.00\n12         06b_stabilisation_util   0.00\n13     07a_treatment_wait(trauma)  53.18\n14     07b_treatment_util(trauma)   0.65\n15          08_total_time(trauma) 197.52\n16                  09_throughput 168.54"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "üí´ Towards Sharing Tools, Artifacts, and Reproducible Simulation: a simmer model example",
    "section": "",
    "text": "Reusehttps://creativecommons.org/licenses/by/4.0/CitationBibTeX citation:@online{monks,\n  author = {Monks, Thomas and Harper, Alison and Heather, Amy and\n    Mustafee, Navonil},\n  title = {üí´ {Towards} {Sharing} {Tools,} {Artifacts,} and\n    {Reproducible} {Simulation:} A `Simmer` Model Example},\n  url = {https://TomMonks.github.io/treat-sim-rsimmer//},\n  doi = {10.5555/12345678_fake},\n  langid = {en},\n  abstract = {The materials and methods in this documentation support\n    work towards developing the **S.T.A.R.S healthcare framework**\n    (**S**haring **T**ools and **A**rtifacts for **R**eproducible\n    **S**imulations in healthcare). Long term S.T.A.R.S aims to support\n    researchers share open simulation models regardless of language\n    choice, improve the quality of sharing, and reduce the workload\n    required to meet high standards of open science for the modelling\n    and simulation community. The code and written materials are a\n    **work in progress** towards STARS version 2.0. It demonstrates the\n    application od sharing a discrete-event simuilation model and\n    associated research artifacts: * All artifacts in this repository\n    are linked to study researchers via ORCIDs; * Model code is made\n    available under a GNU Public License version 3; * {[}**To do**:\n    validate and test R dependencies managed through `renv`{]} * The R\n    code and simmer model are documented and explained in a quarto\n    website served up by GitHub pages; * {[}**To do**: the materials are\n    deposited and made citatable using Zenodo;{]} * {[}**To do**: The\n    models are sharable with other researchers and the NHS without the\n    need to install software.{]}}\n}\nFor attribution, please cite this work as:\nMonks, Thomas, Alison Harper, Amy Heather, and Navonil Mustafee. n.d.\n‚Äúüí´ Towards Sharing Tools, Artifacts, and Reproducible Simulation:\nA `Simmer` Model Example.‚Äù Zenodo. https://doi.org/10.5555/12345678_fake."
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Abstract",
    "section": "",
    "text": "The materials and methods in this documentation support work towards developing the S.T.A.R.S healthcare framework (Sharing Tools and Artifacts for Reproducible Simulations in healthcare). Long term S.T.A.R.S aims to support researchers share open simulation models regardless of language choice, improve the quality of sharing, and reduce the workload required to meet high standards of open science for the modelling and simulation community.\nThe code and written materials are a work in progress towards STARS version 2.0. It demonstrates the application od sharing a discrete-event simuilation model and associated research artifacts:\n\nAll artifacts in this repository are linked to study researchers via ORCIDs;\nModel code is made available under a GNU Public License version 3;\n[To do: validate and test R dependencies managed through renv]\nThe R code and simmer model are documented and explained in a quarto website served up by GitHub pages;\n[To do: the materials are deposited and made citatable using Zenodo;]\n[To do: The models are sharable with other researchers and the NHS without the need to install software.]"
  },
  {
    "objectID": "preface.html#towards-sharing-tools-artifacts-and-reproducible-simulation-a-simmer-model-example",
    "href": "preface.html#towards-sharing-tools-artifacts-and-reproducible-simulation-a-simmer-model-example",
    "title": "Abstract",
    "section": "",
    "text": "The materials and methods in this documentation support work towards developing the S.T.A.R.S healthcare framework (Sharing Tools and Artifacts for Reproducible Simulations in healthcare). Long term S.T.A.R.S aims to support researchers share open simulation models regardless of language choice, improve the quality of sharing, and reduce the workload required to meet high standards of open science for the modelling and simulation community.\nThe code and written materials are a work in progress towards STARS version 2.0. It demonstrates the application od sharing a discrete-event simuilation model and associated research artifacts:\n\nAll artifacts in this repository are linked to study researchers via ORCIDs;\nModel code is made available under a GNU Public License version 3;\n[To do: validate and test R dependencies managed through renv]\nThe R code and simmer model are documented and explained in a quarto website served up by GitHub pages;\n[To do: the materials are deposited and made citatable using Zenodo;]\n[To do: The models are sharable with other researchers and the NHS without the need to install software.]"
  },
  {
    "objectID": "02_model/02_thinning.html",
    "href": "02_model/02_thinning.html",
    "title": "Time-dependent arrivals",
    "section": "",
    "text": "The treatment simulation model has a time-dependent arrival profile for patients. To simulated these arrivals correctly in DES we need to use one of several algorithms. Here we make use of the thinning algorithm.\nThinning is a acceptance-rejection sampling method and is used to generate inter-arrival times from a NSPP.\n\nMotivation: In DES we use thinning as an approach to generate time dependent arrival of patients to a health care service.\n\n\n\nThe table below is adapted from Banks et al (2013) and breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between patient arrivals.\n\n\n\n\nA NSPP has arrival rate \\(\\lambda(t)\\) where \\(0 \\leq t \\leq T\\)\nHere \\(i\\) is the arrival number and \\(\\mathcal{T_i}\\) is its arrival time.\n\nLet \\(\\lambda^* = \\max_{0 \\leq t \\leq T}\\lambda(t)\\) be the maximum of the arrival rate function and set \\(t = 0\\) and \\(i=1\\)\nGenerate \\(e\\) from the exponential distribution with rate \\(\\lambda^*\\) and let \\(t = t + e\\) (this is the time of the next entity will arrive)\nGenerate \\(u\\) from the \\(U(0,1)\\) distribution. If \\(u \\leq \\dfrac{\\lambda(t)}{\\lambda^*}\\) then \\(\\mathcal{T_i} =t\\) and \\(i = i + 1\\)\nGo to Step 2."
  },
  {
    "objectID": "02_model/02_thinning.html#background",
    "href": "02_model/02_thinning.html#background",
    "title": "Time-dependent arrivals",
    "section": "",
    "text": "The treatment simulation model has a time-dependent arrival profile for patients. To simulated these arrivals correctly in DES we need to use one of several algorithms. Here we make use of the thinning algorithm.\nThinning is a acceptance-rejection sampling method and is used to generate inter-arrival times from a NSPP.\n\nMotivation: In DES we use thinning as an approach to generate time dependent arrival of patients to a health care service.\n\n\n\nThe table below is adapted from Banks et al (2013) and breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between patient arrivals.\n\n\n\n\nA NSPP has arrival rate \\(\\lambda(t)\\) where \\(0 \\leq t \\leq T\\)\nHere \\(i\\) is the arrival number and \\(\\mathcal{T_i}\\) is its arrival time.\n\nLet \\(\\lambda^* = \\max_{0 \\leq t \\leq T}\\lambda(t)\\) be the maximum of the arrival rate function and set \\(t = 0\\) and \\(i=1\\)\nGenerate \\(e\\) from the exponential distribution with rate \\(\\lambda^*\\) and let \\(t = t + e\\) (this is the time of the next entity will arrive)\nGenerate \\(u\\) from the \\(U(0,1)\\) distribution. If \\(u \\leq \\dfrac{\\lambda(t)}{\\lambda^*}\\) then \\(\\mathcal{T_i} =t\\) and \\(i = i + 1\\)\nGo to Step 2."
  },
  {
    "objectID": "02_model/02_thinning.html#imports",
    "href": "02_model/02_thinning.html#imports",
    "title": "Time-dependent arrivals",
    "section": "2. Imports",
    "text": "2. Imports\n\nlibrary(simmer)\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))"
  },
  {
    "objectID": "02_model/02_thinning.html#read-in-data",
    "href": "02_model/02_thinning.html#read-in-data",
    "title": "Time-dependent arrivals",
    "section": "3. Read in data",
    "text": "3. Read in data\nHere we read in the example non-stationary data and compute the arrival rate.\n\nNSPP_PATH = 'https://raw.githubusercontent.com/TomMonks/treat-sim-rsimmer/main/data/nspp_example1.csv'\n\ncsv_data &lt;- getURL(NSPP_PATH)\narrivals &lt;- read.csv(text=csv_data)\nnames(arrivals) &lt;- c(\"period\", \"mean_iat\")\n\n# create arrival rate\narrivals$arrival_rate = 1.0 / arrivals$mean_iat\n\narrivals\n\n  period mean_iat arrival_rate\n1      0       15   0.06666667\n2     60       12   0.08333333\n3    120        7   0.14285714\n4    180        5   0.20000000\n5    240        8   0.12500000\n6    300       10   0.10000000\n7    360       15   0.06666667\n8    420       20   0.05000000\n9    480       20   0.05000000\n\n\n\nggplot(data=arrivals, aes(x=period, y=mean_iat)) +\n  geom_bar(stat=\"identity\", fill=\"steelblue\") + \n  xlab(\"Time of day (mins)\") + \n  ylab(\"Mean IAT (min)\")"
  },
  {
    "objectID": "02_model/02_thinning.html#algorithm-implementation",
    "href": "02_model/02_thinning.html#algorithm-implementation",
    "title": "Time-dependent arrivals",
    "section": "4. Algorithm implementation",
    "text": "4. Algorithm implementation\n\n4.1 NSPP sampling function\n\nnspp_thinning &lt;- function(simulation_time, data, debug=FALSE){\n  \n  # calc time interval: assumes intervals are of equal length\n  interval &lt;- data$period[2] - data$period[1]\n  \n  # maximum arrival rate (smallest time between arrivals)\n  lambda_max &lt;- max(data$arrival_rate)\n\n  while(TRUE){\n    # get time bucket (row of dataframe to use)\n    t &lt;- floor(simulation_time / interval) %% nrow(data) + 1\n    lambda_t &lt;- data$arrival_rate[t]\n    \n    # set to a large number so that at least 1 sample is taken\n    u &lt;- Inf\n    rejects &lt;- -1\n    \n    # running total of time until next arrival\n    inter_arrival_time &lt;- 0.0\n    \n    # reject proportionate to lambda_t / lambda_max\n    ratio &lt;- lambda_t / lambda_max\n    while(u &gt;= ratio){\n      rejects &lt;- rejects + 1\n      # sample using max arrival rate\n      inter_arrival_time &lt;- inter_arrival_time + rexp(1, lambda_max)\n      u &lt;- runif(1, 0.0, 1.0)\n    }\n    \n    if(debug){\n      print({paste(\"Time:\", simulation_time, \n                   \" Rejections:\", rejects, \n                   \" t:\", t, \n                   \" lambda_t:\", lambda_t, \n                   \" IAT:\", inter_arrival_time)})\n    }\n      \n    return(inter_arrival_time)\n  }\n}\n\n\n\n4.2 Example usage\nThe function can be used in the same way as rexp to generate new patients. To illustrate its use we first create a simple patient pathway trajectory that prints out some event and acts as a delay.\n\npatient &lt;- trajectory(\"patient pathway\") %&gt;% \n  # just a simple delay\n  log_(function() {paste(\"Patient arrival\")}, level = 1) %&gt;% \n  timeout(function() rnorm(1, 10.0, 1.0)) %&gt;% \n  log_(function() {paste(\"Exit treatment pathway\")}, level = 1)\n\nWe then run the model with a generator that uses the nspp_thinning sampling function. Note that the function accepts the current simulation time now(env) and the dataframe containing the arrivals arrivals.\n\nImportant learning point: we need to detach run from the creation of the simulation environment. This will allow now(env) to run correctly. If we ignore this rule and include run in the creation pipe the same time will be passed to the thinning function and it will under/over sample arrivals. See https://r-simmer.org/articles/simmer-03-trajectories.html\n\n\nenv &lt;- simmer(\"TreatSim\", log_level=0) \n\nenv %&gt;% \n  add_generator(\"patient\", patient, \n                function() nspp_thinning(now(env), arrivals, debug=TRUE)) %&gt;% \n  run(until=540.0)\n\n[1] \"Time: 0  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 0.783412652574236\"\n[1] \"Time: 0.783412652574236  Rejections: 1  t: 1  lambda_t: 0.0666666666666667  IAT: 24.959008617929\"\n[1] \"Time: 25.7424212705032  Rejections: 0  t: 1  lambda_t: 0.0666666666666667  IAT: 9.64792472268355\"\n[1] \"Time: 35.3903459931868  Rejections: 5  t: 1  lambda_t: 0.0666666666666667  IAT: 26.9955873095843\"\n[1] \"Time: 62.3859333027711  Rejections: 5  t: 2  lambda_t: 0.0833333333333333  IAT: 13.2531918258651\"\n[1] \"Time: 75.6391251286362  Rejections: 1  t: 2  lambda_t: 0.0833333333333333  IAT: 1.55188468206356\"\n[1] \"Time: 77.1910098106998  Rejections: 0  t: 2  lambda_t: 0.0833333333333333  IAT: 0.85081564017805\"\n[1] \"Time: 78.0418254508778  Rejections: 0  t: 2  lambda_t: 0.0833333333333333  IAT: 1.59268388393671\"\n[1] \"Time: 79.6345093348146  Rejections: 0  t: 2  lambda_t: 0.0833333333333333  IAT: 0.862160124816\"\n[1] \"Time: 80.4966694596306  Rejections: 2  t: 2  lambda_t: 0.0833333333333333  IAT: 21.4331835265014\"\n[1] \"Time: 101.929852986132  Rejections: 1  t: 2  lambda_t: 0.0833333333333333  IAT: 7.90322707712135\"\n[1] \"Time: 109.833080063253  Rejections: 2  t: 2  lambda_t: 0.0833333333333333  IAT: 11.4822709317109\"\n[1] \"Time: 121.315350994964  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 4.33196910170323\"\n[1] \"Time: 125.647320096667  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 9.91665207738888\"\n[1] \"Time: 135.563972174056  Rejections: 1  t: 3  lambda_t: 0.142857142857143  IAT: 2.55863748025149\"\n[1] \"Time: 138.122609654308  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 1.79052524967119\"\n[1] \"Time: 139.913134903979  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 1.87351693211346\"\n[1] \"Time: 141.786651836092  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 21.3676320935104\"\n[1] \"Time: 163.154283929603  Rejections: 1  t: 3  lambda_t: 0.142857142857143  IAT: 15.9335681580092\"\n[1] \"Time: 179.087852087612  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 0.453290224540979\"\n[1] \"Time: 179.541142312153  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 12.8973254275726\"\n[1] \"Time: 192.438467739726  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.201774630695581\"\n[1] \"Time: 192.640242370421  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 5.36530695834613\"\n[1] \"Time: 198.005549328767  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 2.78856308897957\"\n[1] \"Time: 200.794112417747  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 1.30035643701528\"\n[1] \"Time: 202.094468854762  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 8.88380269477975\"\n[1] \"Time: 210.978271549542  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 7.72774111437512\"\n[1] \"Time: 218.706012663917  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.118965262081474\"\n[1] \"Time: 218.824977925998  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.652338962331974\"\n[1] \"Time: 219.47731688833  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 5.89041986016041\"\n[1] \"Time: 225.367736748491  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.390568543225527\"\n[1] \"Time: 225.758305291716  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.98930332576856\"\n[1] \"Time: 226.747608617485  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.460945074465288\"\n[1] \"Time: 227.20855369195  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 6.8786406747759\"\n[1] \"Time: 234.087194366726  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 5.15448755097991\"\n[1] \"Time: 239.241681917706  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.258852883707732\"\n[1] \"Time: 239.500534801414  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 1.60319508519024\"\n[1] \"Time: 241.103729886604  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 7.9814496352793\"\n[1] \"Time: 249.085179521883  Rejections: 1  t: 5  lambda_t: 0.125  IAT: 8.78258515573007\"\n[1] \"Time: 257.867764677613  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 2.90078448408458\"\n[1] \"Time: 260.768549161698  Rejections: 1  t: 5  lambda_t: 0.125  IAT: 15.2932765957186\"\n[1] \"Time: 276.061825757417  Rejections: 1  t: 5  lambda_t: 0.125  IAT: 3.92720333496348\"\n[1] \"Time: 279.98902909238  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 10.640234061818\"\n[1] \"Time: 290.629263154198  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 2.65486059710383\"\n[1] \"Time: 293.284123751302  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 0.366098023401414\"\n[1] \"Time: 293.650221774703  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 2.80324171762913\"\n[1] \"Time: 296.453463492333  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 13.8838152951541\"\n[1] \"Time: 310.337278787487  Rejections: 5  t: 6  lambda_t: 0.1  IAT: 37.5443030241372\"\n[1] \"Time: 347.881581811624  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 5.23993168470866\"\n[1] \"Time: 353.121513496332  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 5.81505749353624\"\n[1] \"Time: 358.936570989869  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 7.74937196270691\"\n[1] \"Time: 366.685942952576  Rejections: 6  t: 7  lambda_t: 0.0666666666666667  IAT: 29.969419847332\"\n[1] \"Time: 396.655362799908  Rejections: 1  t: 7  lambda_t: 0.0666666666666667  IAT: 8.08030803666866\"\n[1] \"Time: 404.735670836576  Rejections: 0  t: 7  lambda_t: 0.0666666666666667  IAT: 3.51695505372931\"\n[1] \"Time: 408.252625890306  Rejections: 0  t: 7  lambda_t: 0.0666666666666667  IAT: 1.95318409241736\"\n[1] \"Time: 410.205809982723  Rejections: 2  t: 7  lambda_t: 0.0666666666666667  IAT: 15.5546986885349\"\n[1] \"Time: 425.760508671258  Rejections: 4  t: 8  lambda_t: 0.05  IAT: 12.3249977273203\"\n[1] \"Time: 438.085506398578  Rejections: 0  t: 8  lambda_t: 0.05  IAT: 5.03450708480194\"\n[1] \"Time: 443.12001348338  Rejections: 1  t: 8  lambda_t: 0.05  IAT: 3.29074969266698\"\n[1] \"Time: 446.410763176047  Rejections: 1  t: 8  lambda_t: 0.05  IAT: 16.7015309053852\"\n[1] \"Time: 463.112294081432  Rejections: 3  t: 8  lambda_t: 0.05  IAT: 44.5938544010622\"\n[1] \"Time: 507.706148482494  Rejections: 2  t: 9  lambda_t: 0.05  IAT: 13.0159013810939\"\n[1] \"Time: 520.722049863588  Rejections: 0  t: 9  lambda_t: 0.05  IAT: 1.14258074434474\"\n[1] \"Time: 521.864630607933  Rejections: 6  t: 9  lambda_t: 0.05  IAT: 44.0995109208309\"\n\n\nsimmer environment: TreatSim | now: 540 | next: 565.964141528764\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 64 }"
  },
  {
    "objectID": "02_model/02_thinning.html#validation",
    "href": "02_model/02_thinning.html#validation",
    "title": "Time-dependent arrivals",
    "section": "5. Validation",
    "text": "5. Validation\n\nThe total number of arrivals in 540 minutes\n\nHere we will repeat the same 10,000 times and then explore the distribution of the number of arrivals. If all has gone to plan this should be a Poisson distribution with mean ~53.\n\n# expected arrivals from data.\nround(sum(arrivals$arrival_rate * 60), 2)\n\n[1] 53.07\n\n\nWe can use the simmer function get_n_generated to return the number of patients generated.\n\narrivals_by_replication &lt;- function(envs){\n  results &lt;- vector()\n  for(env in envs){\n    results &lt;- c(results, get_n_generated(env, \"patient\"))\n  }\n  return(data.frame(results))\n}\n\n\nsingle_run &lt;- function(env, rep_number, run_length, debug_arrivals=FALSE){\n  env %&gt;% \n    add_generator(\"patient\", patient, \n                  function() nspp_thinning(now(env), arrivals, debug=debug_arrivals)) %&gt;% \n    run(until=540.0)\n  return(env)\n}\n\n\nRUN_LENGTH &lt;- 540.0\nN_REPS &lt;- 500\nSEED &lt;- 42\n\nset.seed(SEED)\n\npatient &lt;- trajectory(\"patient pathway\") %&gt;% \n  # just a simple delay\n  log_(function() {paste(\"Exit treatment pathway\")}, level = 1)\n\n# note unlike in simmer documentation we use a traditional for loop\n# instead of lapply. This allows us to separeate env creation\n# from run and preserve the environment interaction between NSPP \n# and current sim time.\nenvs = vector()\nfor(rep in 1:N_REPS){\n  env &lt;- simmer(\"TreatSim\", log_level=0) \n  single_run(env, i, RUN_LENGTH)\n  envs &lt;- c(envs, env)\n}\n\n# # get the number of arrivals generated\nresults &lt;- arrivals_by_replication(envs)\n\n# show mean number of arrivals. Should be close to 53\nmean(results$results)\n\n[1] 53.552\n\n\n\nggplot(results, aes(x=results)) + \n  geom_histogram(binwidth=1, fill=\"steelblue\") + \n  xlab(\"Patient arrivals in 540 minutes\") + \n  ylab(\"Replications\")"
  },
  {
    "objectID": "02_model/02_thinning.html#running-code",
    "href": "02_model/02_thinning.html#running-code",
    "title": "Time-dependent arrivals",
    "section": "Running Code",
    "text": "Running Code\nWhen you click the Render button a document will be generated that includes both content and the output of embedded code. You can embed code like this:\n\n1 + 1\n\n[1] 2\n\n\nYou can add options to executable code like this\n\n\n[1] 4\n\n\nThe echo: false option disables the printing of code (only output is displayed)."
  }
]