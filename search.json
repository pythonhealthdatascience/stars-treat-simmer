[
  {
    "objectID": "02_model/03_r_sampling.html",
    "href": "02_model/03_r_sampling.html",
    "title": "Sampling in R",
    "section": "",
    "text": "By default R offers less control over random sampling than python and commercial simulation software. It uses a single random number stream for all sampling and does not allow you to create individual random number streams (each with its own seed) for each sampling distribution.\n\nThis is not ideal for DES, and has a range of impacts. The one you will likely experience is additional noise between experiments due to this lack of control. Another way to describe this is that changes in sampling distribution parameters and particularly arrival rates may cause experiments to go out of sync where the same patients experience different activity duration and routing due to random sampling differences across scenarios rather than the systematic differences you have introduced in your experiments.\nThe result of this random noise is that typically you will need to run a lot more replications to carefully assess difference between experiments than if it were reduced/eliminated. It is also harder to debug experiments.\n\nThis notebook will:\n\nDemonstrate the shortcomings of a single random number stream and how noise is introduced between experiments.\nIllustrate that problem with a simple simmer model that varies arrival rates\nIntroduce up to 25 random streams for sampling using the SimEd R package."
  },
  {
    "objectID": "02_model/03_r_sampling.html#overview",
    "href": "02_model/03_r_sampling.html#overview",
    "title": "Sampling in R",
    "section": "",
    "text": "By default R offers less control over random sampling than python and commercial simulation software. It uses a single random number stream for all sampling and does not allow you to create individual random number streams (each with its own seed) for each sampling distribution.\n\nThis is not ideal for DES, and has a range of impacts. The one you will likely experience is additional noise between experiments due to this lack of control. Another way to describe this is that changes in sampling distribution parameters and particularly arrival rates may cause experiments to go out of sync where the same patients experience different activity duration and routing due to random sampling differences across scenarios rather than the systematic differences you have introduced in your experiments.\nThe result of this random noise is that typically you will need to run a lot more replications to carefully assess difference between experiments than if it were reduced/eliminated. It is also harder to debug experiments.\n\nThis notebook will:\n\nDemonstrate the shortcomings of a single random number stream and how noise is introduced between experiments.\nIllustrate that problem with a simple simmer model that varies arrival rates\nIntroduce up to 25 random streams for sampling using the SimEd R package."
  },
  {
    "objectID": "02_model/03_r_sampling.html#imports",
    "href": "02_model/03_r_sampling.html#imports",
    "title": "Sampling in R",
    "section": "1. Imports",
    "text": "1. Imports\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nlibrary(magrittr)\nsuppressMessages(library(simEd))\nsuppressMessages(library(tidyr))"
  },
  {
    "objectID": "02_model/03_r_sampling.html#a-simple-motivating-example",
    "href": "02_model/03_r_sampling.html#a-simple-motivating-example",
    "title": "Sampling in R",
    "section": "2. A simple motivating example",
    "text": "2. A simple motivating example\nTo illustrate the impact of this design consider the example below. Imagine we are going to simulate 5 patients length of stay (LoS) in an acute hospital followed by rehabilitation. Acute LoS is exponentially distribution while rehabilitation LoS follows a uniform distribution (the choice of distribution does not matter).\n\nIMPORTANT: To make the as results “repeatable” as possible we will set a random seed. With a single random stream we will see that this does not guarantee repeatable samples for patients between experiments.\n\n\n2.1 Constants\n\nSEED &lt;- 42\nACUTE_MEAN &lt;- 32.0\nREHAB_MIN &lt;- 15.0\nREHAB_MAX &lt;- 80.0\n\n\n\n2.2 Experiment 1\n\nn_patients &lt;- 5\n\nset.seed(SEED)\nacute_los &lt;- rexp(n=n_patients, rate=1.0/ACUTE_MEAN)\nrehab_los &lt;- runif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX)\n\nprint(acute_los)\n\n[1]  6.346778 21.148648  9.071713  1.222141 15.141652\n\nprint(rehab_los)\n\n[1] 23.75333 57.70450 60.82921 44.75322 61.74230\n\n\n\n\n2.3 Experiment 2\nWe will now reset the random stream using the same seed and limit the number of patients simulated to 2.\nWhen we re-run the code we might expect to get\n\nAcute Los:\n6.346778 21.148648\nRehab Los:\n23.75333 57.70450\n\nBut we will see that this does not happen. This is because all sampling makes use of a pseudo random number stream that generates uniformly distribution numbers \\(U\\)’s between 0 and 1. When only 1 stream is used for all sampling we can end up with lots of noise between experiments simply because different \\(U\\)’s are used for the same patients.\n\nn_patients &lt;- 2\n\nset.seed(SEED)\nacute_los &lt;- rexp(n=n_patients, rate=1.0/ACUTE_MEAN)\nrehab_los &lt;- runif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX)\n\nprint(acute_los)\n\n[1]  6.346778 21.148648\n\nprint(rehab_los)\n\n[1] 56.71346 48.74124"
  },
  {
    "objectID": "02_model/03_r_sampling.html#force-the-order-of-sampling",
    "href": "02_model/03_r_sampling.html#force-the-order-of-sampling",
    "title": "Sampling in R",
    "section": "3. Force the order of sampling",
    "text": "3. Force the order of sampling\nTo force the order of sampling within a single random number stream each patient must do their sampling upfront and in process order.\nBelow we re-run Experiments 1 and 2, but this time we make sure the process is sampled in order (acute then rehab) for each patient.\n\n3.1 A Return to Experiment 1\n\nn_patients &lt;- 3\n\nset.seed(SEED)\n\nfor (patient_i in 1:n_patients) {\n    print(paste(\"Patient \", patient_i))\n    print(paste(\"Acute \", rexp(n=1, rate=1.0/ACUTE_MEAN)))\n    print(paste(\"Rehab \", runif(n=1, min=REHAB_MIN, max=REHAB_MAX)))\n}\n\n[1] \"Patient  1\"\n[1] \"Acute  6.34677797708443\"\n[1] \"Rehab  68.9790956943762\"\n[1] \"Patient  2\"\n[1] \"Acute  9.07171320915222\"\n[1] \"Rehab  48.7412366934586\"\n[1] \"Patient  3\"\n[1] \"Acute  15.1416521370411\"\n[1] \"Rehab  23.7533288204577\"\n\n\n\n\n3.2 A Return to Experiment 2\n\nn_patients &lt;- 2\n\nset.seed(SEED)\n\nfor (patient_i in 1:n_patients) {\n    print(paste(\"Patient \", patient_i))\n    print(paste(\"Acute \", rexp(n=1, rate=1.0/ACUTE_MEAN)))\n    print(paste(\"Rehab \", runif(n=1, min=REHAB_MIN, max=REHAB_MAX)))\n}\n\n[1] \"Patient  1\"\n[1] \"Acute  6.34677797708443\"\n[1] \"Rehab  68.9790956943762\"\n[1] \"Patient  2\"\n[1] \"Acute  9.07171320915222\"\n[1] \"Rehab  48.7412366934586\""
  },
  {
    "objectID": "02_model/03_r_sampling.html#a-simmer-model",
    "href": "02_model/03_r_sampling.html#a-simmer-model",
    "title": "Sampling in R",
    "section": "4. A simmer model",
    "text": "4. A simmer model\nBy default simmer will be affected by the single random stream for all sampling. This is because in a DES there is no guarantee that sampling will not occur in process order like we saw above. The numbers generated will vary depending on when events are scheduled to take place.\nWe will first consider this in experiments where we set the exact number of arrivals to the model. In these experiments we will not use resources. This means that there is no impact on the model due to queuing if we increase or decrease the number of arrivals to the model.\n\n4.1 Experiment 1 (5 arrivals)\n\n# set the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_1\", log_level=1) \n\n# setup simple patient trajectory\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  set_attribute(\"start_acute\", function() {now(env)}) %&gt;%\n  timeout(function() rexp(1, rate=1.0/ACUTE_MEAN)) %&gt;% \n  set_attribute(\"acute_los\", function() {now(env) - get_attribute(env, \"start_acute\")}) %&gt;%\n  log_(function() {paste(\"Acute LoS \", now(env) - get_attribute(env, \"start_acute\"))},\n       level=1) %&gt;%\n  set_attribute(\"start_rehab\", function() {now(env)}) %&gt;%\n  timeout(function() runif(n=1, min=REHAB_MIN, max=REHAB_MAX)) %&gt;% \n  set_attribute(\"rehab_los\", function() {now(env) - get_attribute(env, \"start_rehab\")}) %&gt;%\n  log_(function() {paste(\"Rehab LoS \", now(env) - get_attribute(env, \"start_rehab\"))},\n       level=1)\n\n\nenv %&gt;% \n  # add 5 arrivals all at the same time.\n  add_generator(\"patient\", patient, at(0, 0, 0, 0, 0)) %&gt;% \n  invisible\n \nenv %&gt;%\n  run() %&gt;% \n  invisible\n\n1.22214: patient3: Acute LoS  1.2221407443285\n6.34678: patient0: Acute LoS  6.34677797708443\n9.07171: patient2: Acute LoS  9.07171320915222\n15.1417: patient4: Acute LoS  15.1416521370411\n21.1486: patient1: Acute LoS  21.1486480683088\n24.9755: patient3: Rehab LoS  23.7533288204577\n59.8949: patient4: Rehab LoS  44.7532154561486\n64.0513: patient0: Rehab LoS  57.704498876119\n69.9009: patient2: Rehab LoS  60.8292109624017\n82.8909: patient1: Rehab LoS  61.7422963574063\n\n\n\n\n4.2 Experiment 2 (3 arrivals)\nHere we setup the model to simulate 3 patients that all arrive as the unit opens. Arrival times are the same, so we may expect the acute and rehab lengths of stay to remain the same. However, we can see that the acute length of stay and rehab length of stay quickly goes out of sync i.e. we have introduced noise between experiments that is nothing to do with the variation in the number of patients (that we changed between experiments). Let’s take patient 0 as an example.\nIn experiment 1:\n\nAcute treatment is 6.3 days\nRehab treatment is 57.7 days\n\nIn experiment 2:\n\nAcute treatment is 6.3 days\nRehab treatment is 48.7 days\n\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_2\", log_level=1) \n\nenv %&gt;% \n  # now limit to 3 patients.\n  add_generator(\"patient\", patient, at(0, 0, 0)) %&gt;% \n  invisible\n \nenv %&gt;%\n  run() %&gt;% \n  invisible\n\n6.34678: patient0: Acute LoS  6.34677797708443\n9.07171: patient2: Acute LoS  9.07171320915222\n21.1486: patient1: Acute LoS  21.1486480683088\n44.902: patient1: Rehab LoS  23.7533288204577\n55.088: patient0: Rehab LoS  48.7412366934586\n71.95: patient2: Rehab LoS  62.8782404516824"
  },
  {
    "objectID": "02_model/03_r_sampling.html#a-simmer-model-with-random-arrivals",
    "href": "02_model/03_r_sampling.html#a-simmer-model-with-random-arrivals",
    "title": "Sampling in R",
    "section": "5. A simmer model with random arrivals",
    "text": "5. A simmer model with random arrivals\nFinally we demonstrate that the effect is still observed across two experiments that vary the parameter of exponentially distributed inter-arrival times. We will run two new experiments. In the first IAT is 10 minutes. The second experiment increases the intensity of arrivals to an IAT of 2.0 minutes.\nThe function get_results_for_patient helps us trace patient 0 as they flowed through the model. The results illustratrate that the acute LoS remains the same, but the rehab LoS is different. As a single stream of random numbers was used, we were unable to control the order in which \\(U\\)’s were used to generate samples from the rehab L distributions.\n\n# helper function to process results \nget_results_for_patient &lt;- function(sim_env, patient_id){\n  results &lt;- subset(get_mon_attributes(sim_env), select = c(name, key, value))\n  results &lt;- spread(results, key, value)\n  return(results[results$name == patient_id,])\n}\n\n\n5.1 IAT ~ Exponential(10.0)\n\nmean_iat = 10.0\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_simmer1\") \n\nenv %&gt;% \n  # expontially distr arrivals mean IAT = 10.0\n  add_generator(\"patient\", patient, function() rexp(1, rate=1.0/mean_iat),\n                mon=2) %&gt;% \n  invisible\n \nenv %&gt;%\n  run(90) %&gt;% \n  invisible\n\n\nresults_exp1 &lt;- get_results_for_patient(env, \"patient0\")\n\n\n\n5.2 IAT ~ Exponential(2.0)\n\nmean_iat = 2.0\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_simmer2\")\n\nenv %&gt;% \n  # modify expontially distr arrivals to mean IAT = 9.0\n  add_generator(\"patient\", patient, function() rexp(1, rate=1.0/mean_iat),\n                mon=2) %&gt;% \n  invisible\n \nenv %&gt;%\n  run(90) %&gt;% \n  invisible\n\nresults_exp2 &lt;- get_results_for_patient(env, \"patient0\")\n\n\ncomparison &lt;- rbind(results_exp1, results_exp2)\ncomparison$name &lt;- c(\"Patient 0 in Exp1\", \"Patient 0 in Exp2\")\ncomparison\n\n\n\n\n\nname\nacute_los\nrehab_los\nstart_acute\nstart_rehab\n\n\n\n\nPatient 0 in Exp1\n9.071713\n60.82921\n1.9833681\n11.055081\n\n\nPatient 0 in Exp2\n9.071713\n76.53344\n0.3966736\n9.468387"
  },
  {
    "objectID": "02_model/03_r_sampling.html#using-the-simed-package",
    "href": "02_model/03_r_sampling.html#using-the-simed-package",
    "title": "Sampling in R",
    "section": "6. Using the simEd package",
    "text": "6. Using the simEd package\nsimEd is an R package aimed at improving simulation education. It makes use of a package called rstream that provides multiple random number streams for DES. simEd provides up to 25 streams and re-implements a useful selection of statistical distributions that can be used.\nDetails of the package can be found here: https://www.rdocumentation.org/packages/simEd/versions/2.0.1\n\nB. Lawson and L. M. Leemis, “An R package for simulation education,” 2017 Winter Simulation Conference (WSC), Las Vegas, NV, USA, 2017, pp. 4175-4186, doi: 10.1109/WSC.2017.8248124 https://ieeexplore.ieee.org/document/8248124\n\n\n6.1 Revisiting our initial experiment\nThe code below re-implements the original experiments we conducted using simEd equivalent sampling functions. The main difference is that we prefix functions with v instead of r. For example rexp becomes vexp. We also introduce a third parameter called stream (settable 1:25).\nThis time when we reduce the number of patients from 5 to 2 the acute and rehab samples remain the same for the first two patients.\n\nn_patients &lt;- 5\n\nset.seed(SEED)\n# replace rexp with vexp and set stream number to 1\nacute_los &lt;- vexp(n=n_patients, rate=1.0/ACUTE_MEAN, stream=1)\n\n# replace runif with vunif and set stream number to 2\nrehab_los &lt;- vunif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX, stream=2)\n\nprint(acute_los)\n\n[1]  0.4526612 13.6325644 29.0375715 38.6327714 24.0971868\n\nprint(rehab_los)\n\n[1] 79.39406 54.01103 59.64871 55.21520 36.20446\n\n\n\nn_patients &lt;- 2\n\nset.seed(SEED)\n# replace rexp with vexp and set stream number to 1\nacute_los &lt;- vexp(n=n_patients, rate=1.0/ACUTE_MEAN, stream=1)\n\n# replace runif with vunif and set stream number to 2\nrehab_los &lt;- vunif(n=n_patients, min=REHAB_MIN, max=REHAB_MAX, stream=2)\n\nprint(acute_los)\n\n[1]  0.4526612 13.6325644\n\nprint(rehab_los)\n\n[1] 79.39406 54.01103\n\n\n\n\n6.2 An updated simmer model\nFinally we update the simmer model to use simEd and compare the results for patient 0 again. As expected we confirm that the sampling of acute and rehab duration is now in sync across the experiments.\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_1_simEd\") \n\n# redefine simple patient trajectory to use simEd variate functions\n# each distribution in the model has its own stream\npatient &lt;- trajectory(\"patient_pathway\") %&gt;% \n  set_attribute(\"start_acute\", function() {now(env)}) %&gt;%\n  timeout(function() vexp(1, rate=1.0/ACUTE_MEAN, stream=1)) %&gt;%  \n  set_attribute(\"acute_los\", function() {now(env) - get_attribute(env, \"start_acute\")}) %&gt;%\n  set_attribute(\"start_rehab\", function() {now(env)}) %&gt;%\n  timeout(function() vunif(n=1, min=REHAB_MIN, max=REHAB_MAX, stream=2)) %&gt;% \n  set_attribute(\"rehab_los\", function() {now(env) - get_attribute(env, \"start_rehab\")}) \n\nenv %&gt;% \n  # exponentially distr arrivals mean IAT = 10.0\n  add_generator(\"patient\", patient, function() vexp(1, rate=1.0/10.0, stream=3),\n                mon=2) %&gt;% \n  invisible\n \nenv %&gt;%\n  run(90) %&gt;% \n  invisible\n\n\n# store results for experiment 1 and patient 0\nresults_exp1 &lt;- get_results_for_patient(env, \"patient0\")\n\n\n# reset the seed\nset.seed(SEED)\n\n# create simmer environment\nenv &lt;- simmer(\"Experiment_2_simEd\") \n\nenv %&gt;% \n  # exponentially distr arrivals mean IAT = 9.0\n  add_generator(\"patient\", patient, function() vexp(1, rate=1.0/2.0, stream=3),\n                mon=2) %&gt;% \n  invisible\n \nenv %&gt;%\n  run(90) %&gt;% \n  invisible\n\n# store results for experiment 2 and patient 0\nresults_exp2 &lt;- get_results_for_patient(env, \"patient0\")\n\n\n# updated comparison\ncomparison &lt;- rbind(results_exp1, results_exp2)\ncomparison$name &lt;- c(\"Patient 0 in Exp1\", \"Patient 0 in Exp2\")\ncomparison\n\n\n\n\n\nname\nacute_los\nrehab_los\nstart_acute\nstart_rehab\n\n\n\n\nPatient 0 in Exp1\n0.4526612\n79.39406\n2.2381819\n2.6908430\n\n\nPatient 0 in Exp2\n0.4526612\n79.39406\n0.4476364\n0.9002976"
  },
  {
    "objectID": "02_model/01_model.html",
    "href": "02_model/01_model.html",
    "title": "Model code",
    "section": "",
    "text": "Note: we are calculating KPIs using our own code here, but you can also use simmer.plot. Help with install of simmer.plot (igraph installation is the actual issue) on Linux based systems: https://r.igraph.org/articles/installation-troubleshooting#cannot-compile-igraph-from-sources-on-linux\n\nIf you make use of conda environments (via Anaconda/mini-conda/mini-forge/mamba), remember to conda deactivate before installation.\n\n\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nsuppressMessages(library(simmer.plot))\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))\nsuppressMessages(library(Rlab))\nsuppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))\n\noptions(dplyr.summarise.inform = FALSE)"
  },
  {
    "objectID": "02_model/01_model.html#imports",
    "href": "02_model/01_model.html#imports",
    "title": "Model code",
    "section": "",
    "text": "Note: we are calculating KPIs using our own code here, but you can also use simmer.plot. Help with install of simmer.plot (igraph installation is the actual issue) on Linux based systems: https://r.igraph.org/articles/installation-troubleshooting#cannot-compile-igraph-from-sources-on-linux\n\nIf you make use of conda environments (via Anaconda/mini-conda/mini-forge/mamba), remember to conda deactivate before installation.\n\n\n\nlibrary(simmer)\nlibrary(simmer.bricks)\nsuppressMessages(library(simmer.plot))\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))\nsuppressMessages(library(Rlab))\nsuppressMessages(library(dplyr))\nsuppressMessages(library(tidyr))\n\noptions(dplyr.summarise.inform = FALSE)"
  },
  {
    "objectID": "02_model/01_model.html#default-values-and-constants",
    "href": "02_model/01_model.html#default-values-and-constants",
    "title": "Model code",
    "section": "2. Default values and constants",
    "text": "2. Default values and constants\n\n2.1 Distribution parameters\n\n#' Mean and Variance of the underlying Normal Distribution\n#' \n#' @description\n#' `normal_moments_from_lognormal` calculates the mu and sigma\n#' of the normal distribution underlying a lognormal\n#' mean and standard \n#'\n#' @details\n#' `rlnorm` from `stats` is designed to sample from the lognormal distribution. \n#' The parameters is expects are moments of the underlying normal distribution\n#' Using sample mean and standard deviation this function calculates \n#' the mu and sigma of the normal distribution. source: https://blogs.sas.com/content/iml/2014/06/04/simulate-lognormal-data-with-specified-mean-and-variance.html\n#' \n#' @param mean A number. Sample mean.\n#' @param stdev A number. Sample standard deviation\n#' @returns A list \nnormal_moments_from_lognormal &lt;- function(mean, std){\n  phi &lt;- sqrt(std^2 + mean^2)\n  mu &lt;- log(mean**2/phi)\n  sigma &lt;- sqrt(log(phi^2/mean^2))\n  return(list(\"mu\" = mu, \"sigma\" = sigma))\n}\n\n\n# sign-in/triage parameters\nDEFAULT_TRIAGE_MEAN &lt;- 3.0\n\n# registration parameters (lognormal distribution)\nDEFAULT_REG_PARAMS &lt;- normal_moments_from_lognormal(5.0, sqrt(2.0))\n\n# examination parameters\nDEFAULT_EXAM_PARAMS = list(mean=16.0, var=3.0)\n\n# trauma/stabilisation\nDEFAULT_TRAUMA_MEAN &lt;- 90.0\n\n# Trauma treatment (lognormal distribution)\nDEFAULT_TRAUMA_TREATMENT_PARAMS &lt;- normal_moments_from_lognormal(30.0, sqrt(4.0))\n\n# Non trauma treatment (lognormal distribution)\nDEFAULT_NON_TRAUMA_TREATMENT_PARAMS &lt;- normal_moments_from_lognormal(13.3, sqrt(2.0))\n\n# prob patient requires treatment given trauma\nDEFAULT_NON_TRAUMA_TREAT_P &lt;- 0.60\n\n# proportion of patients triaged as trauma\nDEFAULT_PROB_TRAUMA &lt;- 0.12\n\n\n\n2.2 Time dependent arrival rate data\nThe data for arrival rates varies between clinic opening at 6am and closure at 12am.\n\n# data are held in the Github repo and loaded from there.\nNSPP_PATH = 'https://raw.githubusercontent.com/TomMonks/open-science-for-sim/main/src/notebooks/01_foss_sim/data/ed_arrivals.csv'\n\ncsv_data &lt;- getURL(NSPP_PATH)\ndf &lt;- read.csv(text=csv_data)\n\n# lock in order of time of day for bar chart display\ndf$period &lt;- factor(df$period, levels = df$period)\n\nggplot(data=df, aes(x=period, y=arrival_rate)) +\n  geom_bar(stat=\"identity\", fill=\"steelblue\") + \n  theme(axis.text.x = element_text(angle = 90, \n                                   vjust = 0.5, \n                                   hjust=1)) +\n  xlab(\"Hour of day\") + \n  ylab(\"Mean arrivals (patients/hr)\")\n\n\n\n\n\n\n2.3 Resource Counts\nInteger count variables representing the number of resources at each activity in the process\n\nDEFAULT_N_TRIAGE &lt;- 1\nDEFAULT_N_REG &lt;- 1\nDEFAULT_N_EXAM &lt;- 3\n\n# stabilisation rooms\nDEFAULT_N_TRAUMA &lt;- 1\n\n# Non-trauma cubicles\nDEFAULT_NON_TRAUMA_CUBICLES &lt;- 1\n\n# trauma pathway cubicles\nDEFAULT_TRAUMA_CUBICLES &lt;- 1\n\n\n\n2.4 Simulation model run settings\n\n# Random seed - this will be investigated for CRN\nSEED &lt;- 42\n\n# default results collection period\nDEFAULT_RESULTS_COLLECTION_PERIOD &lt;- 60 * 19\n\n# number of replications.\nDEFAULT_N_REPS &lt;- 5\n\n# Show the a trace of simulated events\n# 1 = show, 0 = do not show.\nLOG_LEVEL &lt;- 1"
  },
  {
    "objectID": "02_model/01_model.html#functions",
    "href": "02_model/01_model.html#functions",
    "title": "Model code",
    "section": "3. Functions",
    "text": "3. Functions\nLoad and format data\n\nload_arrival_data &lt;- function(path=NSPP_PATH){\n  csv_data &lt;- getURL(NSPP_PATH)\n  df &lt;- read.csv(text=csv_data)\n  \n  # arrivals per minute...\n  df$arrival_rate2 &lt;- df$arrival_rate/60.0\n  \n  # create 60 minute increments for period\n  df$period = seq(0, (nrow(df)-1)*60, by=60)\n  return(df)\n}\n\n\n#' Sample a patient type\n#' \n#' @description\n#' `sample_arrival_type` samples if a patient type is trauma or non-trauma\n#' with a given probability.\n#'\n#' @details\n#' The function uses the Bernouli distribution (Rlab) to sample\n#' if a patient is Trauma or Non-Trauma.  The return values are \n#' 1 = Trauma, 2 = Non-trauma.\n#' @param p A number: the probability a patient has trauma on arrival\nsample_arrival_type &lt;- function(p, n=1){\n  ifelse(rbern(n, prob = DEFAULT_PROB_TRAUMA) == 1, 1, 2)\n}\n\n\n#' Sample a if a non-trauma patient requires treatment\n#' \n#' @description\n#' `sample_nt_trauma_treatment` samples if a non-trauma patient\n#' requires cubicle treatment\n#'\n#' @details\n#' The function uses the Bernouli distribution (Rlab) to sample\n#' if a patient is requires treatment or not.  The return values are \n#' 1 = Treatment, 0 = No treatment\n#' @param p A number: The probability the patient requires treatment\nsample_nt_trauma_treatment &lt;- function(p){\n  ifelse(rbern(1, prob = p) == 1, 1, 0)\n}\n\nSampling from a non-stationary poisson process using thinning\n\nnspp_thinning &lt;- function(simulation_time, data, debug=FALSE){\n  \n  # calc time interval: assumes intervals are of equal length\n  interval &lt;- data$period[2] - data$period[1]\n  \n  # maximum arrival rate (smallest time between arrivals)\n  lambda_max &lt;- max(data$arrival_rate2)\n\n  while(TRUE){\n    # get time bucket (row of dataframe to use)\n    t &lt;- floor(simulation_time / interval) %% nrow(data) + 1\n    lambda_t &lt;- data$arrival_rate2[t]\n    \n    # set to a large number so that at least 1 sample is taken\n    u &lt;- Inf\n    rejects &lt;- -1\n    \n    # running total of time until next arrival\n    inter_arrival_time &lt;- 0.0\n    \n    # reject proportionate to lambda_t / lambda_max\n    ratio &lt;- lambda_t / lambda_max\n    while(u &gt;= ratio){\n      rejects &lt;- rejects + 1\n      # sample using max arrival rate\n      inter_arrival_time &lt;- inter_arrival_time + rexp(1, lambda_max)\n      u &lt;- runif(1, 0.0, 1.0)\n    }\n    \n    if(debug){\n      print({paste(\"Time:\", simulation_time, \n                   \" Rejections:\", rejects, \n                   \" t:\", t, \n                   \" lambda_t:\", lambda_t, \n                   \" IAT:\", inter_arrival_time)})\n    }\n      \n    return(inter_arrival_time)\n  }\n}"
  },
  {
    "objectID": "02_model/01_model.html#model-parameterisation",
    "href": "02_model/01_model.html#model-parameterisation",
    "title": "Model code",
    "section": "4. Model parameterisation",
    "text": "4. Model parameterisation\nThe model is setup to be created from a set of functions that return trajectories. Each function accepts a list that contains all parameters to configure the simulation model. Here we create the list and pre-populate it using default values.\n\ncreate_experiment &lt;- function(n_triage_bays=DEFAULT_N_TRIAGE,\n                              n_reg_clerks=DEFAULT_N_REG,\n                              n_exam_rooms=DEFAULT_N_EXAM,\n                              n_trauma_rooms=DEFAULT_N_TRAUMA,\n                              n_non_trauma_cubicles=DEFAULT_NON_TRAUMA_CUBICLES,\n                              n_trauma_cubicles=DEFAULT_TRAUMA_CUBICLES,\n                              triage_mean=DEFAULT_TRIAGE_MEAN,\n                              stabilisation_mean=DEFAULT_TRAUMA_MEAN,\n                              trauma_treat_params=DEFAULT_TRAUMA_TREATMENT_PARAMS,\n                              reg_params=DEFAULT_REG_PARAMS,\n                              exam_params=DEFAULT_EXAM_PARAMS,\n                              prob_non_trauma_treat=DEFAULT_NON_TRAUMA_TREAT_P,\n                              nontrauma_treat_params=DEFAULT_NON_TRAUMA_TREATMENT_PARAMS,\n                              prob_trauma=DEFAULT_PROB_TRAUMA,\n                              arrival_data_path=NSPP_PATH,\n                              log_level=LOG_LEVEL) {\n  \n  # load arrival data\n  arrival_data &lt;- load_arrival_data(path=arrival_data_path)\n  \n  # create list of parameters\n  experiment &lt;- list(n_triage_bays=n_triage_bays,\n                    n_reg_clerks=n_reg_clerks,\n                    n_exam_rooms=n_exam_rooms,\n                    n_trauma_rooms=n_trauma_rooms,\n                    n_non_trauma_cubicles=n_non_trauma_cubicles,\n                    n_trauma_cubicles=n_trauma_cubicles,\n                    triage_mean=triage_mean,\n                    stabilisation_mean=stabilisation_mean,\n                    trauma_treat_params=trauma_treat_params,\n                    reg_params=reg_params,\n                    exam_params=exam_params,\n                    prob_non_trauma_treat=prob_non_trauma_treat,\n                    nontrauma_treat_params=nontrauma_treat_params,\n                    prob_trauma=prob_trauma,\n                    arrival_data=arrival_data,\n                    log_level=log_level)\n  \n  return(experiment)\n}"
  },
  {
    "objectID": "02_model/01_model.html#patient-trajectories",
    "href": "02_model/01_model.html#patient-trajectories",
    "title": "Model code",
    "section": "5. Patient Trajectories",
    "text": "5. Patient Trajectories\nThe DES package simmer uses the concept of a trajectory to model a process for a particular patient type. In the urgent care centre example trajectories allow us to model separate trauma and non-trauma processes. Note that different trajectories can share common resources.\nThe simmer terminology for using resources and engaging in activities is easy to read:\n\nseize - queue and take a resource when it is available.\ntimeout - a process delay (e.g. treatment or diagnostics)\nrelease - release a resource.\n\nsimmer also provides a way to set an attribute of the trajectory using set_attribute. This is useful for storing timing information to display in a log: for example when a patient begins waiting for a resource (access via now(env)).\n\nImportant notes:\n\nThe function log_ is used in combination with function() paste to provide a dynamic simulation trace to the R console.\nSampling code should look as follows:\n\ntimeout(task = function() rexp(1, 3.0)) %&gt;%\n\nThe keyword function() must be included for dynamic sampling for each patient. Omitting function() means that it is evaluated once at the time the trajectory is created.\n\n\n\n5.1. Trauma Patients\n\nWe wrap the trajectory in a function called create_trauma_pathway. This allows us to pass an argument exp that can parameterise the trajectory for use in a discrete experiment.\n\n\ncreate_trauma_pathway &lt;- function(exp){\n    \n    trauma_pathway &lt;- trajectory(name=\"trauma_pathway\") %&gt;%\n      set_attribute(\"patient_type\", 1) %&gt;%\n      # log patient arrival\n      log_(function() {paste(\"**Trauma arrival\")}, level=1) %&gt;% \n      \n      # triage \n      set_attribute(\"start_triage_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"triage_bay\", function() rexp(1, 1/exp$triage_mean)) %&gt;%\n      log_(function() {paste(\"(T) Triage wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n           level=1) %&gt;%\n      \n      # request trauma room for stabilization\n      set_attribute(\"start_trauma_room_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"trauma_room\", function() rexp(1, 1/exp$stabilisation_mean)) %&gt;%\n      log_(function() {paste(\"(T) Trauma room wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_trauma_room_wait\"))},\n           level=1) %&gt;%\n      \n      # request treatment cubicle\n      set_attribute(\"start_trauma_treat_wait\", function() {now(exp$env)}) %&gt;%\n      visit(\"trauma_treat_cubicle\", function() rlnorm(1, exp$trauma_treat_params$mu,\n                                                      exp$trauma_treat_params$sigma)) %&gt;%\n      log_(function() {paste(\"********************(T) Trauma treatment cubicle wait time:\",\n                       now(exp$env) - get_attribute(exp$env, \"start_trauma_treat_wait\"))},\n           level=1) %&gt;% \n    \n      # store the total time in system \n      set_attribute(\"total_time\", \n                    function() {now(exp$env) - get_attribute(exp$env, \"start_triage_wait\")})\n    \n  return(trauma_pathway)\n}\n\n\n\n5.2 Non-trauma patients\n\ncreate_nt_cubicle_treatment &lt;- function(exp){\n\n  nt_cubicle_treatment &lt;- trajectory() %&gt;% \n    log_(function() {paste(\"NT patient requirement treatment\")},\n         level=1) %&gt;% \n    seize(resource=\"nontrauma_treat_cubicle\", amount=1) %&gt;% \n    \n    timeout(task = function() rlnorm(1, exp$nontrauma_treat_params$mu,                                                     exp$nontrauma_treat_params$sigma)) %&gt;%\n    release(resource = \"nontrauma_treat_cubicle\", amount = 1) %&gt;% \n    log_(function() {paste(\"NT treatment complete\")},\n     level=1) %&gt;% \n  return(nt_cubicle_treatment)\n}\n\n\ncreate_non_trauma_pathway &lt;- function(exp){\n  # log messages\n  ARRIVAL_MSG = \"**Non-Trauma arrival**\"\n  TRIAGE_MSG = \"(NT) Triage wait time:\"\n  REG_MSG = \"Reg wait time:\"\n  EXAM_MSG = \"Exam wait time:\"\n  EXIT_MSG = \"NT Total time in system:\"\n  \n  # optional trajectory for proportion of patients that requirement treatment\n  nt_cubicle_treatment &lt;- create_nt_cubicle_treatment(exp)\n  \n  non_trauma_pathway &lt;- trajectory(name=\"non_trauma_pathway\") %&gt;%\n    set_attribute(\"patient_type\", 2) %&gt;%\n    # log non_trauma arrival\n    log_(function() {paste(ARRIVAL_MSG)}, level=1) %&gt;% \n    \n    # store start of waiting time for log calculations\n    set_attribute(\"start_triage_wait\", function() {now(exp$env)}) %&gt;%\n    # queue and use triage bay\n    visit(\"triage_bay\", function() rexp(1, 1/exp$triage_mean)) %&gt;%\n    log_(function() {paste(TRIAGE_MSG, now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %&gt;%\n    \n    # queue and use registration clerk\n    set_attribute(\"start_reg_wait\", function() {now(exp$env)}) %&gt;%\n    visit(\"registration_clerk\", function() rlnorm(1, exp$reg_params$mu, \n                                                  exp$reg_params$sigma)) %&gt;%\n    log_(function() {paste(REG_MSG, now(exp$env) - get_attribute(exp$env, \"start_reg_wait\"))},\n         level=1) %&gt;%\n    \n    # queue and use examination room\n    set_attribute(\"start_exam_wait\", function() {now(exp$env)}) %&gt;%\n    visit(\"examination_room\",  function() rnorm(1, exp$exam_params$mean, \n                                                sqrt(exp$exam_params$var))) %&gt;%\n    log_(function() {paste(EXAM_MSG, now(exp$env) - get_attribute(exp$env, \"start_exam_wait\"))},\n         level=1) %&gt;%\n    \n    # a Proportion of patients require treatment in a cubicle\n    branch (\n      function() sample_nt_trauma_treatment(exp$prob_non_trauma_treat), continue=T,\n      nt_cubicle_treatment\n    ) %&gt;% \n    log_(function() {paste(EXIT_MSG, now(exp$env) - get_attribute(exp$env, \"start_triage_wait\"))},\n         level=1) %&gt;% \n    # store the total time in system \n    set_attribute(\"total_time\", \n                    function() {now(exp$env) - get_attribute(exp$env, \"start_triage_wait\")})\n  \n  return(non_trauma_pathway)\n}"
  },
  {
    "objectID": "02_model/01_model.html#modelling-patient-arrivals",
    "href": "02_model/01_model.html#modelling-patient-arrivals",
    "title": "Model code",
    "section": "6. Modelling patient arrivals",
    "text": "6. Modelling patient arrivals\nPatients arrive a the urgent treatment centre following a time dependent process. When patients arrive they are classified as trauma or non-trauma.\nTo modify the classification of patients we will use a trajectory that uses the `branch` function from simmer.\nThe function `sample_arrival_type` returns a 1 (trauma) or 2 (non-trauma). This is used to select the appropriate patient trajectory.\n\ncreate_arrival_generator &lt;- function(exp){\n  \n  DEPART_MSG &lt;- \"A patient has departed the UTC\"\n  \n  # create and parameterise the trauma pathway trajectory\n  trauma_pathway &lt;- create_trauma_pathway(exp)\n  \n  # create and parameterise the non-trauma pathway trajectory\n  non_trauma_pathway &lt;- create_non_trauma_pathway(exp)\n  \n  patient_arrival &lt;- trajectory() %&gt;%\n    branch(\n      function() sample_arrival_type(exp$prob_trauma), continue=T,\n        trauma_pathway,\n        non_trauma_pathway\n    ) %&gt;%\n    log_(function() {paste(DEPART_MSG)},level=1) %&gt;% \n    set_attribute(\"departed\", 1)\n  \n  return(patient_arrival)\n}"
  },
  {
    "objectID": "02_model/01_model.html#single-run-of-the-model",
    "href": "02_model/01_model.html#single-run-of-the-model",
    "title": "Model code",
    "section": "7. Single run of the model",
    "text": "7. Single run of the model\n\nWork in progress\n\n\nsingle_run &lt;- function(env, exp, \n                       rep_number=1, \n                       run_length=DEFAULT_RESULTS_COLLECTION_PERIOD, \n                       debug_arrivals=FALSE){\n  # add the simmer environment to the experiment list.\n  exp &lt;- c(exp, env=env) \n  \n  # Create the arrivals generator\n  arrival_gen &lt;- create_arrival_generator(exp)\n  \n  # create model and run.\n  env %&gt;% \n    add_resource(\"triage_bay\", exp$n_triage_bays) %&gt;%\n    add_resource(\"registration_clerk\", exp$n_reg_clerks) %&gt;%\n    add_resource(\"examination_room\", exp$n_exam_rooms) %&gt;%\n    add_resource(\"trauma_room\", exp$n_trauma_rooms) %&gt;%\n    add_resource(\"trauma_treat_cubicle\", exp$n_trauma_cubicles) %&gt;%\n    add_resource(\"nontrauma_treat_cubicle\", exp$n_non_trauma_cubicles) %&gt;%\n    add_generator(\"Patient\", arrival_gen, \n                  function() nspp_thinning(now(env), exp$arrival_data, \n                                           debug=debug_arrivals),\n                  mon=2) %&gt;% \n    run(until=run_length)\n  \n  # return environment and all of its results.\n  return(env)\n}\n\nScript to conduct single run of the model\n\nNote that the environment is created outside of the single_run function. This is to separate the creation of the environment from the run function call. The reason is so that the now(env) function will work correctly in the nspp_thinning sampling function (if we do not separate then the same time is always passed to the function).\n\n\nset.seed(SEED)\nexp &lt;- create_experiment(log_level=0)\ntreat_sim &lt;- simmer(\"TreatSim\", log_level=exp$log_level)\ntreat_sim &lt;- single_run(treat_sim, exp)\nprint(\"Simulation Complete.\")\n\n[1] \"Simulation Complete.\""
  },
  {
    "objectID": "02_model/01_model.html#multiple-replications",
    "href": "02_model/01_model.html#multiple-replications",
    "title": "Model code",
    "section": "8. Multiple replications",
    "text": "8. Multiple replications\n\nmultiple_replications &lt;- function(exp, n_reps=5, random_seed=0){\n  \n  # set seed in once place.  No CRN\n  set.seed(random_seed)\n  \n  # note unlike in simmer documentation we use a traditional for loop\n  # instead of lapply. This allows us to separate env creation\n  # from run and preserve the environment interaction between NSPP \n  # and current sim time.\n  # TO DO: look again -&gt; can treat_sim be created inside single_run()\n  print(\"running replications...\")\n  reps = vector()\n  for(rep in 1:n_reps){\n    treat_sim &lt;- simmer(\"TreatSimmer\", log_level=exp$log_level)\n    treat_sim &lt;- single_run(treat_sim, exp)\n    # store the latest simulation environment and its results.\n    reps &lt;- c(reps, treat_sim)\n  }\n  print(\"Complete.\")\n  return(reps)\n}\n\n\n# create experiment\nexp &lt;- create_experiment(log_level=0)\n\n# run 50 replications of the model\nreps &lt;- multiple_replications(exp, n_reps=50, random_seed=0)\n\n[1] \"running replications...\"\n[1] \"Complete.\""
  },
  {
    "objectID": "02_model/01_model.html#results-analysis",
    "href": "02_model/01_model.html#results-analysis",
    "title": "Model code",
    "section": "9. Results analysis",
    "text": "9. Results analysis\nAnalysis of simmer results is achieved using a mix of statistics collected automatically and custom attributes set by the modeller during the run.\nIn general, we follow a typical strategy in a simulation study. We calculate the mean Key Performance Indicator (KPI) seen during an individual replication of the model (e.g. waiting time for triage and utilisation of the the triage rooms). This is repeated for all replications and the distribution of results can be visualised or we use a summary measure such as the mean.\nBelow we construct a summary table of results providing the mean of 16 KPIs.\nWe assemble the table of KPIs across replications using the following key functions\n\nresource_waiting_times_by_replication - creates a data frame where columns report the mean waiting time within a replication for a activity in the model (e.g. triage waiting time)\nresource_utilisation_by_replication - creates a data frame where columns report the utilisation of a resource within a replication (e.g. the proportion of the scheduled time that triage bays are in use).\narrivals_by_replication - creates a data frame of the total number of patient arrivals in a replication.\nsystem_kpi_by_replication - creates a data frame containing system level KPIs by replication e.g. throughput and time in system (created from custom attributes).\nreplication_results_table - creates the overall data frame using the other functions.\n\n\nCode quality is a work in progress. 😃\n\n\n9.1. Waiting time KPIs\n\n# assumes df is monitored arrivals\nwaiting_time &lt;- function(df){\n  df$waiting_time &lt;-df$end_time - df$start_time - df$activity_time  \n  return(df)\n}\n\nresource_waiting_times_by_replication &lt;- function(reps) {\n  # - WAITING TIMES FOR RESOURCES - #\n  \n  cols &lt;- c(\"resource\", \"replication\")\n  waiting_times_wide &lt;- get_mon_arrivals(reps, per_resource=TRUE) %&gt;%\n    # waiting time = end time - start time - activity time\n    waiting_time() %&gt;% \n    # mean waiting time in each replication\n    group_by(across(all_of(cols))) %&gt;%\n    # mean for each replication\n    summarise(rep_waiting_time=mean(waiting_time)) %&gt;% \n    # recode kpi names\n    mutate(resource=recode(resource,\n                       'triage_bay'='01a_triage_wait',\n                       'registration_clerk'='02a_registration_wait',\n                       'examination_room'='03a_examination_wait',\n                       'nontrauma_treat_cubicle'='04a_treatment_wait(non_trauma)',\n                       'trauma_room'='06a_stabilisation_wait',\n                       'trauma_treat_cubicle'='07a_treatment_wait(trauma)')) %&gt;%\n    # organise\n    arrange(resource) %&gt;% \n    # long to wide format ...\n    spread(resource, rep_waiting_time)\n  \n  return(waiting_times_wide)\n}\n\n\n\n9.2. Resource utilisation KPIs\n\nget_resource_counts &lt;- function(exp) {\n  resource = c(\"triage_bay\", \n                \"registration_clerk\", \n                \"examination_room\",\n                \"trauma_room\",\n                \"trauma_treat_cubicle\",\n                \"nontrauma_treat_cubicle\")\n  \n  resource_counts = c(exp$n_triage_bays,\n                      exp$n_reg_clerks,\n                      exp$n_exam_rooms,\n                      exp$n_trauma_rooms,\n                      exp$n_trauma_cubicles,\n                      exp$n_non_trauma_cubicles)\n  \n  df_resource &lt;- data.frame(resource)\n  df_resource$count &lt;- resource_counts\n  return(df_resource)\n}\n\n\n# simple calculation of total busy time / total scheduled resource time.\nresource_utilisation &lt;- function(df, scheduled_time){\n   df$util = df$in_use / (scheduled_time * df$count)  \n   return(df)\n}\n\n# calculate resource utilisation and return table (rows = reps and cols = resources)\nresource_utilisation_by_replication &lt;- function(reps, exp, results_collection_period){\n  \n  # get results dataframe broken down by resource and replication.\n  cols &lt;- c(\"resource\", \"replication\")\n    \n  # utilisation calculation:\n  # simple calculation of total busy time / total scheduled resource time.\n  # where total scheduled time = n_resource * results collection period.\n  util_wide &lt;- get_mon_arrivals(reps, per_resource=TRUE) %&gt;%\n    # total activity time in each replication per resource (long format)\n    group_by(across(all_of(cols))) %&gt;%\n    summarise(in_use=sum(activity_time)) %&gt;% \n    # merge with the number of resources available\n    merge(get_resource_counts(exp), by=\"resource\", all=TRUE) %&gt;% \n    # calculate the utilisation using scheduled resource availability\n    resource_utilisation(results_collection_period) %&gt;% \n    # drop total activity time and count of resources\n    subset(select = c(replication, resource, util)) %&gt;% \n    # recode names\n    mutate(resource=recode(resource,\n                       'triage_bay'='01b_triage_util',\n                       'registration_clerk'='02b_registration_util',\n                       'examination_room'='03b_examination_util',\n                       'nontrauma_treat_cubicle'='04b_treatment_util(non_trauma)',\n                       'trauma_room'='06b_stabilisation_util',\n                       'trauma_treat_cubicle'='07b_treatment_util(trauma)')) %&gt;%\n    arrange(resource) %&gt;% \n    # long to wide format...\n    spread(resource, util)\n    \n  return(util_wide)\n}\n\n\n\n9.3. Patient arrival numbers output\n\n# number of arrivals in each replication\narrivals_by_replication &lt;- function(envs){\n  results &lt;- vector()\n  for(env in envs){\n    results &lt;- c(results, get_n_generated(env, \"Patient\"))\n  }\n \n  results &lt;- data.frame(replication = c(1:length(results)), \n                        arrivals = results)\n  colnames(results) &lt;- c(\"replication\", \"00_arrivals\")\n  return(results)\n}\n\n\n\n9.4 System level KPIs\n\n# mean time in the system and throughput\nsystem_kpi_for_rep_i &lt;- function(reps, rep_i){\n  \n  # get attributes\n  att &lt;- get_mon_attributes(reps)\n  \n  # for speed - limit to replication number.\n  data_wide &lt;- subset(att[att$replication == rep_i,], select = c(name, key, value)) %&gt;% \n    spread(key, value)\n\n  # Patient type 1: trauma\n  # take the mean and ignore patients still in pathway\n  mean_time_1 = mean(data_wide[data_wide$patient_type == 1,]$total_time, na.rm = TRUE)\n  \n  # Patient type 2: non_trauma\n  # take the mean and ignore patients still in pathway\n  mean_time_2 = mean(data_wide[data_wide$patient_type == 2,]$total_time, na.rm = TRUE)\n  \n  # Throughput - discharges during opening hours.\n  throughput &lt;- sum(data_wide$departed, na.rm=TRUE)\n  \n  # store and return data.frame of results\n  rep_results &lt;- data.frame(\"replication\" = rep_i,\n                            \"05_total_time(non-trauma)\" = mean_time_2,\n                            \"08_total_time(trauma)\" = mean_time_1, \n                            \"09_throughput\"= throughput)\n  \n  colnames(rep_results) = c(\"replication\",\n                            \"05_total_time(non-trauma)\",\n                            \"08_total_time(trauma)\", \n                            \"09_throughput\")\n  return(rep_results)\n}\n\n\nsystem_kpi_by_replication &lt;- function(reps){\n  # calcs total time by patient type and total throughput\n  \n  # empty dataframe for attribute calculations.\n  att_results &lt;- data.frame(matrix(ncol = 4, nrow = 0))\n  colnames(att_results) &lt;- c(\"replication\", \n                             \"05_total_time(non-trauma)\", \n                             \"08_total_time(trauma)\", \n                             \"_09_throughput\")\n\n  # add each rep separately as this works faster with pivot\n  for(rep_i in 1:length(reps)){\n    att_results &lt;- rbind(att_results, system_kpi_for_rep_i(reps, rep_i))\n  }\n\n  # return the KPIs by replications\n  return(att_results)\n}\n\n\n\n9.5. Function to create the replications table\n\nreplication_results_table &lt;- function(reps, exp, results_collection_period){\n  # generate and merge all results tables on the replication column\n  results_table &lt;- arrivals_by_replication(reps) %&gt;% \n    merge(resource_waiting_times_by_replication(reps), by=\"replication\", all=TRUE) %&gt;% \n    merge(resource_utilisation_by_replication(reps, exp,\n                                              results_collection_period), \n          by=\"replication\", all=TRUE) %&gt;% \n    merge(system_kpi_by_replication(reps), by=\"replication\", all=TRUE) %&gt;% \n    # sort by column names to get \"replication\" followed by ordered 00_, 01a, 01b and so on...\n    select(replication, sort(tidyselect::peek_vars()))\n  \n  results_table \n}\n\nrep_table &lt;- replication_results_table(reps, exp, DEFAULT_RESULTS_COLLECTION_PERIOD)\n\nhead(rep_table)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreplication\n00_arrivals\n01a_triage_wait\n01b_triage_util\n02a_registration_wait\n02b_registration_util\n03a_examination_wait\n03b_examination_util\n04a_treatment_wait(non_trauma)\n04b_treatment_util(non_trauma)\n05_total_time(non-trauma)\n06a_stabilisation_wait\n06b_stabilisation_util\n07a_treatment_wait(trauma)\n07b_treatment_util(trauma)\n08_total_time(trauma)\n09_throughput\n\n\n\n\n1\n227\n38.510472\n0.6500712\n55.63581\n0.8313868\n33.71627\n0.8440569\n161.3438\n0.8528225\n224.4021\n322.3138\n0.6826987\n4.930242\n0.2696664\n448.4067\n149\n\n\n2\n217\n39.962735\n0.5764697\n92.59627\n0.8241213\n24.76566\n0.8355781\n120.8921\n0.8715918\n232.8177\n341.0050\n0.7482643\n20.730095\n0.3229111\n501.7710\n167\n\n\n3\n220\n8.028919\n0.5145182\n125.19868\n0.8363566\n22.93733\n0.8317090\n151.4920\n0.8235007\n226.3541\n175.9264\n0.8472946\n4.735720\n0.4148506\n273.4123\n149\n\n\n4\n207\n32.157743\n0.5447273\n100.08161\n0.7600335\n22.39284\n0.7850996\n104.7379\n0.8154391\n227.6200\n217.9818\n0.8518988\n11.741513\n0.3679632\n358.0275\n153\n\n\n5\n220\n17.281597\n0.5382466\n95.79616\n0.8497077\n29.89311\n0.8479559\n124.9008\n0.8803980\n213.6180\n163.9983\n0.6404862\n5.159307\n0.1560905\n347.3643\n145\n\n\n6\n244\n19.722275\n0.6032575\n139.37281\n0.8861767\n13.59604\n0.8731107\n150.0938\n0.8974080\n247.6859\n220.1141\n0.8915800\n5.252764\n0.3437842\n310.7147\n167\n\n\n\n\n\n\n\n\n9.6 Histogram of replications\n\nhistogram_of_replications &lt;- function(rep_table, column_name, unit_label, n_bins=10){\n  \n  # Divide the x range for selected column into n_bins\n  binwidth &lt;- diff(range(select(rep_table, all_of(column_name))))/n_bins\n  \n  g &lt;- ggplot(rep_table, aes(.data[[column_name]])) +\n   geom_histogram(binwidth = binwidth, fill=\"steelblue\", colour = \"black\") + \n    xlab(paste(column_name, \" (\", unit_label, \")\")) + \n    ylab(\"Replications\")\n  \n  return(g)\n}\n\n# as numeric names make sure to pass column name in ticks ``\nhistogram_of_replications(rep_table, \"09_throughput\", \"patients/day\", n_bins=10)\n\n\n\n\n\n\n9.7 Results summary table\n\n# modified summary table function\ncreate_summary_table &lt;- function(rep_table, dp=2){\n  # mean of all columns, but ignore rep number\n  mean_values &lt;- data.frame(colMeans(rep_table[c(2:length(rep_table))]))\n  colnames(mean_values) &lt;- c(\"mean\")\n  return(round(mean_values, dp))\n\n}\ncreate_summary_table(rep_table)\n\n\n\n\n\n\nmean\n\n\n\n\n00_arrivals\n227.28\n\n\n01a_triage_wait\n34.24\n\n\n01b_triage_util\n0.60\n\n\n02a_registration_wait\n104.06\n\n\n02b_registration_util\n0.83\n\n\n03a_examination_wait\n23.60\n\n\n03b_examination_util\n0.83\n\n\n04a_treatment_wait(non_trauma)\n126.82\n\n\n04b_treatment_util(non_trauma)\n0.86\n\n\n05_total_time(non-trauma)\n229.06\n\n\n06a_stabilisation_wait\n217.85\n\n\n06b_stabilisation_util\n0.74\n\n\n07a_treatment_wait(trauma)\n7.22\n\n\n07b_treatment_util(trauma)\n0.27\n\n\n08_total_time(trauma)\n354.38\n\n\n09_throughput\n154.86"
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Abstract",
    "section": "",
    "text": "The materials and methods in this documentation support work towards developing the S.T.A.R.S healthcare framework (Sharing Tools and Artifacts for Reproducible Simulations in healthcare). Long term S.T.A.R.S aims to support researchers share open simulation models regardless of language choice, improve the quality of sharing, and reduce the workload required to meet high standards of open science for the modelling and simulation community.\nThe code and written materials are a work in progress towards STARS version 2.0. It demonstrates the application od sharing a discrete-event simuilation model and associated research artifacts:\n\nAll artifacts in this repository are linked to study researchers via ORCIDs;\nModel code is made available under a GNU Public License version 3;\n[To do: validate and test R dependencies managed through renv]\nThe R code and simmer model are documented and explained in a quarto website served up by GitHub pages;\n[To do: the materials are deposited and made citatable using Zenodo;]\n[To do: The models are sharable with other researchers and the NHS without the need to install software.]"
  },
  {
    "objectID": "preface.html#towards-sharing-tools-artifacts-and-reproducible-simulation-a-simmer-model-example",
    "href": "preface.html#towards-sharing-tools-artifacts-and-reproducible-simulation-a-simmer-model-example",
    "title": "Abstract",
    "section": "",
    "text": "The materials and methods in this documentation support work towards developing the S.T.A.R.S healthcare framework (Sharing Tools and Artifacts for Reproducible Simulations in healthcare). Long term S.T.A.R.S aims to support researchers share open simulation models regardless of language choice, improve the quality of sharing, and reduce the workload required to meet high standards of open science for the modelling and simulation community.\nThe code and written materials are a work in progress towards STARS version 2.0. It demonstrates the application od sharing a discrete-event simuilation model and associated research artifacts:\n\nAll artifacts in this repository are linked to study researchers via ORCIDs;\nModel code is made available under a GNU Public License version 3;\n[To do: validate and test R dependencies managed through renv]\nThe R code and simmer model are documented and explained in a quarto website served up by GitHub pages;\n[To do: the materials are deposited and made citatable using Zenodo;]\n[To do: The models are sharable with other researchers and the NHS without the need to install software.]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "💫 Towards Sharing Tools, Artifacts, and Reproducible Simulation: a simmer model example",
    "section": "",
    "text": "Reusehttps://creativecommons.org/licenses/by/4.0/CitationBibTeX citation:@online{monks,\n  author = {Monks, Thomas and Harper, Alison and Heather, Amy and\n    Mustafee, Navonil},\n  title = {💫 {Towards} {Sharing} {Tools,} {Artifacts,} and\n    {Reproducible} {Simulation:} A `Simmer` Model Example},\n  url = {https://pythonhealthdatascience.github.io/stars-treat-simmer//},\n  doi = {10.5555/12345678_fake},\n  langid = {en},\n  abstract = {The materials and methods in this documentation support\n    work towards developing the **S.T.A.R.S healthcare framework**\n    (**S**haring **T**ools and **A**rtifacts for **R**eproducible\n    **S**imulations in healthcare). Long term S.T.A.R.S aims to support\n    researchers share open simulation models regardless of language\n    choice, improve the quality of sharing, and reduce the workload\n    required to meet high standards of open science for the modelling\n    and simulation community. The code and written materials are a\n    **work in progress** towards STARS version 2.0. It demonstrates the\n    application od sharing a discrete-event simuilation model and\n    associated research artifacts: * All artifacts in this repository\n    are linked to study researchers via ORCIDs; * Model code is made\n    available under the MIT license; * {[}**To do**: validate and test R\n    dependencies managed through `renv`{]} * The R code and simmer model\n    are documented and explained in a quarto website served up by GitHub\n    pages; * {[}**To do**: the materials are deposited and made\n    citatable using Zenodo;{]} * {[}**To do**: The models are sharable\n    with other researchers and the NHS without the need to install\n    software.{]}}\n}\nFor attribution, please cite this work as:\nMonks, Thomas, Alison Harper, Amy Heather, and Navonil Mustafee. n.d.\n“💫 Towards Sharing Tools, Artifacts, and Reproducible Simulation:\nA `Simmer` Model Example.” Zenodo. https://doi.org/10.5555/12345678_fake."
  },
  {
    "objectID": "01_introduction/02_license.html",
    "href": "01_introduction/02_license.html",
    "title": "License",
    "section": "",
    "text": "All model and analysis code is licensed under the MIT license.\n\n\n\nAll written content in this book is shared under CC-BY 4.0.\nYou are free to:\nShare - copy and redistribute the material in any medium or format\n\nAdapt - remix, transform, and build upon the material for any purpose, even commercially.\nYou must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use."
  },
  {
    "objectID": "01_introduction/02_license.html#code-and-model",
    "href": "01_introduction/02_license.html#code-and-model",
    "title": "License",
    "section": "",
    "text": "All model and analysis code is licensed under the MIT license."
  },
  {
    "objectID": "01_introduction/02_license.html#written-materials",
    "href": "01_introduction/02_license.html#written-materials",
    "title": "License",
    "section": "",
    "text": "All written content in this book is shared under CC-BY 4.0.\nYou are free to:\nShare - copy and redistribute the material in any medium or format\n\nAdapt - remix, transform, and build upon the material for any purpose, even commercially.\nYou must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use."
  },
  {
    "objectID": "02_model/02_thinning.html",
    "href": "02_model/02_thinning.html",
    "title": "Time-dependent arrivals",
    "section": "",
    "text": "The treatment simulation model has a time-dependent arrival profile for patients. To simulated these arrivals correctly in DES we need to use one of several algorithms. Here we make use of the thinning algorithm.\nThinning is a acceptance-rejection sampling method and is used to generate inter-arrival times from a NSPP.\n\nMotivation: In DES we use thinning as an approach to generate time dependent arrival of patients to a health care service.\n\n\n\nThe table below is adapted from Banks et al (2013) and breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between patient arrivals.\n\n\n\n\nA NSPP has arrival rate \\(\\lambda(t)\\) where \\(0 \\leq t \\leq T\\)\nHere \\(i\\) is the arrival number and \\(\\mathcal{T_i}\\) is its arrival time.\n\nLet \\(\\lambda^* = \\max_{0 \\leq t \\leq T}\\lambda(t)\\) be the maximum of the arrival rate function and set \\(t = 0\\) and \\(i=1\\)\nGenerate \\(e\\) from the exponential distribution with rate \\(\\lambda^*\\) and let \\(t = t + e\\) (this is the time of the next entity will arrive)\nGenerate \\(u\\) from the \\(U(0,1)\\) distribution. If \\(u \\leq \\dfrac{\\lambda(t)}{\\lambda^*}\\) then \\(\\mathcal{T_i} =t\\) and \\(i = i + 1\\)\nGo to Step 2."
  },
  {
    "objectID": "02_model/02_thinning.html#background",
    "href": "02_model/02_thinning.html#background",
    "title": "Time-dependent arrivals",
    "section": "",
    "text": "The treatment simulation model has a time-dependent arrival profile for patients. To simulated these arrivals correctly in DES we need to use one of several algorithms. Here we make use of the thinning algorithm.\nThinning is a acceptance-rejection sampling method and is used to generate inter-arrival times from a NSPP.\n\nMotivation: In DES we use thinning as an approach to generate time dependent arrival of patients to a health care service.\n\n\n\nThe table below is adapted from Banks et al (2013) and breaks an arrival process down into 60 minutes intervals.\n\n\n\n\n\n\n\n\nt(min)\nMean time between arrivals (min)\nArrival Rate \\(\\lambda(t)\\) (arrivals/min)\n\n\n\n\n0\n15\n1/15\n\n\n60\n12\n1/12\n\n\n120\n7\n1/7\n\n\n180\n5\n1/5\n\n\n240\n8\n1/8\n\n\n300\n10\n1/10\n\n\n360\n15\n1/15\n\n\n420\n20\n1/20\n\n\n480\n20\n1/20\n\n\n\n\nInterpretation: In the table above the fastest arrival rate is 1/5 customers per minute or 5 minutes between patient arrivals.\n\n\n\n\nA NSPP has arrival rate \\(\\lambda(t)\\) where \\(0 \\leq t \\leq T\\)\nHere \\(i\\) is the arrival number and \\(\\mathcal{T_i}\\) is its arrival time.\n\nLet \\(\\lambda^* = \\max_{0 \\leq t \\leq T}\\lambda(t)\\) be the maximum of the arrival rate function and set \\(t = 0\\) and \\(i=1\\)\nGenerate \\(e\\) from the exponential distribution with rate \\(\\lambda^*\\) and let \\(t = t + e\\) (this is the time of the next entity will arrive)\nGenerate \\(u\\) from the \\(U(0,1)\\) distribution. If \\(u \\leq \\dfrac{\\lambda(t)}{\\lambda^*}\\) then \\(\\mathcal{T_i} =t\\) and \\(i = i + 1\\)\nGo to Step 2."
  },
  {
    "objectID": "02_model/02_thinning.html#imports",
    "href": "02_model/02_thinning.html#imports",
    "title": "Time-dependent arrivals",
    "section": "2. Imports",
    "text": "2. Imports\n\nlibrary(simmer)\nlibrary(tibble)\nlibrary(ggplot2)\nsuppressMessages(library(RCurl))"
  },
  {
    "objectID": "02_model/02_thinning.html#read-in-data",
    "href": "02_model/02_thinning.html#read-in-data",
    "title": "Time-dependent arrivals",
    "section": "3. Read in data",
    "text": "3. Read in data\nHere we read in the example non-stationary data and compute the arrival rate.\n\nNSPP_PATH = 'https://raw.githubusercontent.com/TomMonks/treat-sim-rsimmer/main/data/nspp_example1.csv'\n\ncsv_data &lt;- getURL(NSPP_PATH)\narrivals &lt;- read.csv(text=csv_data)\nnames(arrivals) &lt;- c(\"period\", \"mean_iat\")\n\n# create arrival rate\narrivals$arrival_rate = 1.0 / arrivals$mean_iat\n\narrivals\n\n  period mean_iat arrival_rate\n1      0       15   0.06666667\n2     60       12   0.08333333\n3    120        7   0.14285714\n4    180        5   0.20000000\n5    240        8   0.12500000\n6    300       10   0.10000000\n7    360       15   0.06666667\n8    420       20   0.05000000\n9    480       20   0.05000000\n\n\n\nggplot(data=arrivals, aes(x=period, y=mean_iat)) +\n  geom_bar(stat=\"identity\", fill=\"steelblue\") + \n  xlab(\"Time of day (mins)\") + \n  ylab(\"Mean IAT (min)\")"
  },
  {
    "objectID": "02_model/02_thinning.html#algorithm-implementation",
    "href": "02_model/02_thinning.html#algorithm-implementation",
    "title": "Time-dependent arrivals",
    "section": "4. Algorithm implementation",
    "text": "4. Algorithm implementation\n\n4.1 NSPP sampling function\n\nnspp_thinning &lt;- function(simulation_time, data, debug=FALSE){\n  \n  # calc time interval: assumes intervals are of equal length\n  interval &lt;- data$period[2] - data$period[1]\n  \n  # maximum arrival rate (smallest time between arrivals)\n  lambda_max &lt;- max(data$arrival_rate)\n\n  while(TRUE){\n    # get time bucket (row of dataframe to use)\n    t &lt;- floor(simulation_time / interval) %% nrow(data) + 1\n    lambda_t &lt;- data$arrival_rate[t]\n    \n    # set to a large number so that at least 1 sample is taken\n    u &lt;- Inf\n    rejects &lt;- -1\n    \n    # running total of time until next arrival\n    inter_arrival_time &lt;- 0.0\n    \n    # reject proportionate to lambda_t / lambda_max\n    ratio &lt;- lambda_t / lambda_max\n    while(u &gt;= ratio){\n      rejects &lt;- rejects + 1\n      # sample using max arrival rate\n      inter_arrival_time &lt;- inter_arrival_time + rexp(1, lambda_max)\n      u &lt;- runif(1, 0.0, 1.0)\n    }\n    \n    if(debug){\n      print({paste(\"Time:\", simulation_time, \n                   \" Rejections:\", rejects, \n                   \" t:\", t, \n                   \" lambda_t:\", lambda_t, \n                   \" IAT:\", inter_arrival_time)})\n    }\n      \n    return(inter_arrival_time)\n  }\n}\n\n\n\n4.2 Example usage\nThe function can be used in the same way as rexp to generate new patients. To illustrate its use we first create a simple patient pathway trajectory that prints out some event and acts as a delay.\n\npatient &lt;- trajectory(\"patient pathway\") %&gt;% \n  # just a simple delay\n  log_(function() {paste(\"Patient arrival\")}, level = 1) %&gt;% \n  timeout(function() rnorm(1, 10.0, 1.0)) %&gt;% \n  log_(function() {paste(\"Exit treatment pathway\")}, level = 1)\n\nWe then run the model with a generator that uses the nspp_thinning sampling function. Note that the function accepts the current simulation time now(env) and the dataframe containing the arrivals arrivals.\n\nImportant learning point: we need to detach run from the creation of the simulation environment. This will allow now(env) to run correctly. If we ignore this rule and include run in the creation pipe the same time will be passed to the thinning function and it will under/over sample arrivals. See https://r-simmer.org/articles/simmer-03-trajectories.html\n\n\nenv &lt;- simmer(\"TreatSim\", log_level=0) \n\nenv %&gt;% \n  add_generator(\"patient\", patient, \n                function() nspp_thinning(now(env), arrivals, debug=TRUE)) %&gt;% \n  run(until=540.0)\n\n[1] \"Time: 0  Rejections: 2  t: 1  lambda_t: 0.0666666666666667  IAT: 12.3170700045055\"\n[1] \"Time: 12.3170700045055  Rejections: 2  t: 1  lambda_t: 0.0666666666666667  IAT: 29.8042921362527\"\n[1] \"Time: 42.1213621407582  Rejections: 4  t: 1  lambda_t: 0.0666666666666667  IAT: 44.3244025730205\"\n[1] \"Time: 86.4457647137787  Rejections: 0  t: 2  lambda_t: 0.0833333333333333  IAT: 1.5125033070694\"\n[1] \"Time: 87.9582680208481  Rejections: 1  t: 2  lambda_t: 0.0833333333333333  IAT: 4.80466362067914\"\n[1] \"Time: 92.7629316415272  Rejections: 0  t: 2  lambda_t: 0.0833333333333333  IAT: 2.07653273129836\"\n[1] \"Time: 94.8394643728255  Rejections: 1  t: 2  lambda_t: 0.0833333333333333  IAT: 12.7656335775265\"\n[1] \"Time: 107.605097950352  Rejections: 1  t: 2  lambda_t: 0.0833333333333333  IAT: 6.69238817158571\"\n[1] \"Time: 114.297486121938  Rejections: 3  t: 2  lambda_t: 0.0833333333333333  IAT: 11.4083337817366\"\n[1] \"Time: 125.705819903674  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 0.232516925316304\"\n[1] \"Time: 125.938336828991  Rejections: 1  t: 3  lambda_t: 0.142857142857143  IAT: 6.2632446431317\"\n[1] \"Time: 132.201581472122  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 1.50837458437309\"\n[1] \"Time: 133.709956056495  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 3.85685536989427\"\n[1] \"Time: 137.56681142639  Rejections: 2  t: 3  lambda_t: 0.142857142857143  IAT: 20.6832564180142\"\n[1] \"Time: 158.250067844404  Rejections: 0  t: 3  lambda_t: 0.142857142857143  IAT: 6.35431296636766\"\n[1] \"Time: 164.604380810772  Rejections: 3  t: 3  lambda_t: 0.142857142857143  IAT: 45.955617979437\"\n[1] \"Time: 210.559998790209  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 1.42062998576036\"\n[1] \"Time: 211.980628775969  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.458430694988776\"\n[1] \"Time: 212.439059470958  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 5.25860620175904\"\n[1] \"Time: 217.697665672717  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 4.17272278086698\"\n[1] \"Time: 221.870388453584  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.229960032738745\"\n[1] \"Time: 222.100348486322  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 0.652627080552088\"\n[1] \"Time: 222.752975566875  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 6.63534692933268\"\n[1] \"Time: 229.388322496207  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 5.01297508811063\"\n[1] \"Time: 234.401297584318  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 2.69523442257196\"\n[1] \"Time: 237.09653200689  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 2.71995460847393\"\n[1] \"Time: 239.816486615364  Rejections: 0  t: 4  lambda_t: 0.2  IAT: 5.35320844014591\"\n[1] \"Time: 245.16969505551  Rejections: 1  t: 5  lambda_t: 0.125  IAT: 6.91582239444783\"\n[1] \"Time: 252.085517449958  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 6.39692617551118\"\n[1] \"Time: 258.482443625469  Rejections: 1  t: 5  lambda_t: 0.125  IAT: 33.31127954999\"\n[1] \"Time: 291.793723175459  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 6.32686956764615\"\n[1] \"Time: 298.120592743105  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 0.6473648018442\"\n[1] \"Time: 298.767957544949  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 0.562435596448654\"\n[1] \"Time: 299.330393141398  Rejections: 0  t: 5  lambda_t: 0.125  IAT: 14.3972218773308\"\n[1] \"Time: 313.727615018728  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 4.03505245840212\"\n[1] \"Time: 317.762667477131  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 12.9321964642472\"\n[1] \"Time: 330.694863941378  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 8.29896487253618\"\n[1] \"Time: 338.993828813914  Rejections: 1  t: 6  lambda_t: 0.1  IAT: 4.86410341841185\"\n[1] \"Time: 343.857932232326  Rejections: 1  t: 6  lambda_t: 0.1  IAT: 8.14657132614103\"\n[1] \"Time: 352.004503558467  Rejections: 1  t: 6  lambda_t: 0.1  IAT: 5.96838979960835\"\n[1] \"Time: 357.972893358075  Rejections: 0  t: 6  lambda_t: 0.1  IAT: 0.566974185257226\"\n[1] \"Time: 358.539867543332  Rejections: 2  t: 6  lambda_t: 0.1  IAT: 17.9213087428416\"\n[1] \"Time: 376.461176286174  Rejections: 2  t: 7  lambda_t: 0.0666666666666667  IAT: 7.19756458909887\"\n[1] \"Time: 383.658740875273  Rejections: 7  t: 7  lambda_t: 0.0666666666666667  IAT: 28.6240846114835\"\n[1] \"Time: 412.282825486756  Rejections: 7  t: 7  lambda_t: 0.0666666666666667  IAT: 37.641882830785\"\n[1] \"Time: 449.924708317541  Rejections: 0  t: 8  lambda_t: 0.05  IAT: 6.7952759422124\"\n[1] \"Time: 456.719984259754  Rejections: 1  t: 8  lambda_t: 0.05  IAT: 6.45498812368717\"\n[1] \"Time: 463.174972383441  Rejections: 2  t: 8  lambda_t: 0.05  IAT: 12.2225909600384\"\n[1] \"Time: 475.397563343479  Rejections: 0  t: 8  lambda_t: 0.05  IAT: 11.025298134725\"\n[1] \"Time: 486.422861478204  Rejections: 5  t: 9  lambda_t: 0.05  IAT: 14.8031513880246\"\n[1] \"Time: 501.226012866229  Rejections: 0  t: 9  lambda_t: 0.05  IAT: 7.47590314554882\"\n[1] \"Time: 508.701916011778  Rejections: 5  t: 9  lambda_t: 0.05  IAT: 36.0732168012259\"\n\n\nsimmer environment: TreatSim | now: 540 | next: 544.775132813004\n{ Monitor: in memory }\n{ Source: patient | monitored: 1 | n_generated: 52 }"
  },
  {
    "objectID": "02_model/02_thinning.html#validation",
    "href": "02_model/02_thinning.html#validation",
    "title": "Time-dependent arrivals",
    "section": "5. Validation",
    "text": "5. Validation\n\nThe total number of arrivals in 540 minutes\n\nHere we will repeat the same 10,000 times and then explore the distribution of the number of arrivals. If all has gone to plan this should be a Poisson distribution with mean ~53.\n\n# expected arrivals from data.\nround(sum(arrivals$arrival_rate * 60), 2)\n\n[1] 53.07\n\n\nWe can use the simmer function get_n_generated to return the number of patients generated.\n\narrivals_by_replication &lt;- function(envs){\n  results &lt;- vector()\n  for(env in envs){\n    results &lt;- c(results, get_n_generated(env, \"patient\"))\n  }\n  return(data.frame(results))\n}\n\n\nsingle_run &lt;- function(env, rep_number, run_length, debug_arrivals=FALSE){\n  env %&gt;% \n    add_generator(\"patient\", patient, \n                  function() nspp_thinning(now(env), arrivals, debug=debug_arrivals)) %&gt;% \n    run(until=540.0)\n  return(env)\n}\n\n\nRUN_LENGTH &lt;- 540.0\nN_REPS &lt;- 500\nSEED &lt;- 42\n\nset.seed(SEED)\n\npatient &lt;- trajectory(\"patient pathway\") %&gt;% \n  # just a simple delay\n  log_(function() {paste(\"Exit treatment pathway\")}, level = 1)\n\n# note unlike in simmer documentation we use a traditional for loop\n# instead of lapply. This allows us to separeate env creation\n# from run and preserve the environment interaction between NSPP \n# and current sim time.\nenvs = vector()\nfor(rep in 1:N_REPS){\n  env &lt;- simmer(\"TreatSim\", log_level=0) \n  single_run(env, i, RUN_LENGTH)\n  envs &lt;- c(envs, env)\n}\n\n# # get the number of arrivals generated\nresults &lt;- arrivals_by_replication(envs)\n\n# show mean number of arrivals. Should be close to 53\nmean(results$results)\n\n[1] 53.552\n\n\n\nggplot(results, aes(x=results)) + \n  geom_histogram(binwidth=1, fill=\"steelblue\") + \n  xlab(\"Patient arrivals in 540 minutes\") + \n  ylab(\"Replications\")"
  }
]